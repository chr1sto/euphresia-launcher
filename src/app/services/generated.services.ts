/* tslint:disable */
/* eslint-disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.1.6.0 (NJsonSchema v10.0.28.0 (Newtonsoft.Json v11.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------
// ReSharper disable InconsistentNaming

import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import { Observable, throwError as _observableThrow, of as _observableOf } from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';

export const API_BASE_URL = new InjectionToken<string>('API_BASE_URL');

@Injectable()
export class AccountService {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "/api";
    }

    /**
     * @param loginViewModel (optional) 
     * @return Success
     */
    login(loginViewModel: LoginViewModel | null | undefined): Observable<ApiResultOfString> {
        let url_ = this.baseUrl + "/v1/account/login";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(loginViewModel);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processLogin(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLogin(<any>response_);
                } catch (e) {
                    return <Observable<ApiResultOfString>><any>_observableThrow(e);
                }
            } else
                return <Observable<ApiResultOfString>><any>_observableThrow(response_);
        }));
    }

    protected processLogin(response: HttpResponseBase): Observable<ApiResultOfString> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApiResultOfString.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ApiResultOfLoginViewModel.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApiResultOfString>(<any>null);
    }

    /**
     * @param registerViewModel (optional) 
     * @return Success
     */
    register(registerViewModel: RegisterViewModel | null | undefined): Observable<ApiResultOfRegisterViewModel> {
        let url_ = this.baseUrl + "/v1/account/register";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(registerViewModel);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRegister(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRegister(<any>response_);
                } catch (e) {
                    return <Observable<ApiResultOfRegisterViewModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<ApiResultOfRegisterViewModel>><any>_observableThrow(response_);
        }));
    }

    protected processRegister(response: HttpResponseBase): Observable<ApiResultOfRegisterViewModel> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApiResultOfRegisterViewModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ApiResultOfRegisterViewModel.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApiResultOfRegisterViewModel>(<any>null);
    }

    /**
     * @param index (optional) 
     * @param count (optional) 
     * @param searchText (optional) 
     * @return Success
     */
    account(index: number | null | undefined, count: number | null | undefined, searchText: string | null | undefined): Observable<ApiResultOfPagedResultDataOfIEnumerableOfApplicationUser> {
        let url_ = this.baseUrl + "/v1/account?";
        if (index !== undefined)
            url_ += "index=" + encodeURIComponent("" + index) + "&"; 
        if (count !== undefined)
            url_ += "count=" + encodeURIComponent("" + count) + "&"; 
        if (searchText !== undefined)
            url_ += "searchText=" + encodeURIComponent("" + searchText) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAccount(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAccount(<any>response_);
                } catch (e) {
                    return <Observable<ApiResultOfPagedResultDataOfIEnumerableOfApplicationUser>><any>_observableThrow(e);
                }
            } else
                return <Observable<ApiResultOfPagedResultDataOfIEnumerableOfApplicationUser>><any>_observableThrow(response_);
        }));
    }

    protected processAccount(response: HttpResponseBase): Observable<ApiResultOfPagedResultDataOfIEnumerableOfApplicationUser> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApiResultOfPagedResultDataOfIEnumerableOfApplicationUser.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ApiResultOfPagedResultDataOfIEnumerableOfApplicationUser.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApiResultOfPagedResultDataOfIEnumerableOfApplicationUser>(<any>null);
    }

    /**
     * @return Success
     */
    accountGetByid(id: string): Observable<ApiResultOfApplicationUser> {
        let url_ = this.baseUrl + "/v1/account/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAccountGetByid(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAccountGetByid(<any>response_);
                } catch (e) {
                    return <Observable<ApiResultOfApplicationUser>><any>_observableThrow(e);
                }
            } else
                return <Observable<ApiResultOfApplicationUser>><any>_observableThrow(response_);
        }));
    }

    protected processAccountGetByid(response: HttpResponseBase): Observable<ApiResultOfApplicationUser> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApiResultOfApplicationUser.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ApiResultOfApplicationUser.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApiResultOfApplicationUser>(<any>null);
    }
}

@Injectable()
export class AccountManagmentService {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "/api";
    }

    /**
     * @return Success
     */
    resendVerificationMail(): Observable<ApiResultOfString> {
        let url_ = this.baseUrl + "/v1/account-managment/resend-verification-mail";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processResendVerificationMail(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processResendVerificationMail(<any>response_);
                } catch (e) {
                    return <Observable<ApiResultOfString>><any>_observableThrow(e);
                }
            } else
                return <Observable<ApiResultOfString>><any>_observableThrow(response_);
        }));
    }

    protected processResendVerificationMail(response: HttpResponseBase): Observable<ApiResultOfString> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApiResultOfString.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ApiResultOfString.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApiResultOfString>(<any>null);
    }

    /**
     * @param code (optional) 
     * @param id (optional) 
     * @return Success
     */
    verifyMail(code: string | null | undefined, id: string | null | undefined): Observable<ApiResultOfString> {
        let url_ = this.baseUrl + "/v1/account-managment/verify-mail?";
        if (code !== undefined)
            url_ += "code=" + encodeURIComponent("" + code) + "&"; 
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processVerifyMail(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processVerifyMail(<any>response_);
                } catch (e) {
                    return <Observable<ApiResultOfString>><any>_observableThrow(e);
                }
            } else
                return <Observable<ApiResultOfString>><any>_observableThrow(response_);
        }));
    }

    protected processVerifyMail(response: HttpResponseBase): Observable<ApiResultOfString> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApiResultOfString.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ApiResultOfString.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApiResultOfString>(<any>null);
    }

    /**
     * @param model (optional) 
     * @return Success
     */
    changePassword(model: ChangePasswordViewModel | null | undefined): Observable<ApiResultOfChangePasswordViewModel> {
        let url_ = this.baseUrl + "/v1/account-managment/change-password";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processChangePassword(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processChangePassword(<any>response_);
                } catch (e) {
                    return <Observable<ApiResultOfChangePasswordViewModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<ApiResultOfChangePasswordViewModel>><any>_observableThrow(response_);
        }));
    }

    protected processChangePassword(response: HttpResponseBase): Observable<ApiResultOfChangePasswordViewModel> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApiResultOfChangePasswordViewModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ApiResultOfChangePasswordViewModel.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApiResultOfChangePasswordViewModel>(<any>null);
    }

    /**
     * @param model (optional) 
     * @return Success
     */
    forgotPassword(model: ForgotPasswordViewModel | null | undefined): Observable<ApiResultOfForgotPasswordViewModel> {
        let url_ = this.baseUrl + "/v1/account-managment/forgot-password";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processForgotPassword(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processForgotPassword(<any>response_);
                } catch (e) {
                    return <Observable<ApiResultOfForgotPasswordViewModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<ApiResultOfForgotPasswordViewModel>><any>_observableThrow(response_);
        }));
    }

    protected processForgotPassword(response: HttpResponseBase): Observable<ApiResultOfForgotPasswordViewModel> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApiResultOfForgotPasswordViewModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ApiResultOfForgotPasswordViewModel.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApiResultOfForgotPasswordViewModel>(<any>null);
    }

    /**
     * @param model (optional) 
     * @return Success
     */
    resetPassword(model: ResetPasswordViewModel | null | undefined): Observable<ApiResultOfResetPasswordViewModel> {
        let url_ = this.baseUrl + "/v1/account-managment/reset-password";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processResetPassword(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processResetPassword(<any>response_);
                } catch (e) {
                    return <Observable<ApiResultOfResetPasswordViewModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<ApiResultOfResetPasswordViewModel>><any>_observableThrow(response_);
        }));
    }

    protected processResetPassword(response: HttpResponseBase): Observable<ApiResultOfResetPasswordViewModel> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApiResultOfResetPasswordViewModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ApiResultOfResetPasswordViewModel.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApiResultOfResetPasswordViewModel>(<any>null);
    }

    /**
     * @return Success
     */
    mailVerified(): Observable<ApiResultOfBoolean> {
        let url_ = this.baseUrl + "/v1/account-managment/mail-verified";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMailVerified(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMailVerified(<any>response_);
                } catch (e) {
                    return <Observable<ApiResultOfBoolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<ApiResultOfBoolean>><any>_observableThrow(response_);
        }));
    }

    protected processMailVerified(response: HttpResponseBase): Observable<ApiResultOfBoolean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApiResultOfBoolean.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ApiResultOfBoolean.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApiResultOfBoolean>(<any>null);
    }
}

@Injectable()
export class DonateService {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "/api";
    }

    /**
     * @param orderId (optional) 
     * @return Success
     */
    verifyPpOrder(orderId: string | null | undefined): Observable<ApiResultOfString> {
        let url_ = this.baseUrl + "/v1/donate/verify-pp-order?";
        if (orderId !== undefined)
            url_ += "orderId=" + encodeURIComponent("" + orderId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processVerifyPpOrder(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processVerifyPpOrder(<any>response_);
                } catch (e) {
                    return <Observable<ApiResultOfString>><any>_observableThrow(e);
                }
            } else
                return <Observable<ApiResultOfString>><any>_observableThrow(response_);
        }));
    }

    protected processVerifyPpOrder(response: HttpResponseBase): Observable<ApiResultOfString> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApiResultOfString.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ApiResultOfString.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApiResultOfString>(<any>null);
    }

    /**
     * @return Success
     */
    balance(): Observable<ApiResultOfInt32> {
        let url_ = this.baseUrl + "/v1/donate/balance";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBalance(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBalance(<any>response_);
                } catch (e) {
                    return <Observable<ApiResultOfInt32>><any>_observableThrow(e);
                }
            } else
                return <Observable<ApiResultOfInt32>><any>_observableThrow(response_);
        }));
    }

    protected processBalance(response: HttpResponseBase): Observable<ApiResultOfInt32> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApiResultOfInt32.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApiResultOfInt32>(<any>null);
    }
}

@Injectable()
export class FileUploadService {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "/api";
    }

    /**
     * @return Success
     */
    fileUploadGet(): Observable<ApiResultOfIEnumerableOfString> {
        let url_ = this.baseUrl + "/v1/file-upload";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFileUploadGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFileUploadGet(<any>response_);
                } catch (e) {
                    return <Observable<ApiResultOfIEnumerableOfString>><any>_observableThrow(e);
                }
            } else
                return <Observable<ApiResultOfIEnumerableOfString>><any>_observableThrow(response_);
        }));
    }

    protected processFileUploadGet(response: HttpResponseBase): Observable<ApiResultOfIEnumerableOfString> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApiResultOfIEnumerableOfString.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ApiResultOfIEnumerableOfString.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApiResultOfIEnumerableOfString>(<any>null);
    }

    /**
     * @param contentType (optional) 
     * @param contentDisposition (optional) 
     * @param headers (optional) 
     * @param length (optional) 
     * @param name (optional) 
     * @param fileName (optional) 
     * @return Success
     */
    fileUploadPost(contentType: string | null | undefined, contentDisposition: string | null | undefined, headers: any | null | undefined, length: number | null | undefined, name: string | null | undefined, fileName: string | null | undefined): Observable<ApiResultOfIFormFile> {
        let url_ = this.baseUrl + "/v1/file-upload";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (contentType !== null && contentType !== undefined)
            content_.append("ContentType", contentType.toString());
        if (contentDisposition !== null && contentDisposition !== undefined)
            content_.append("ContentDisposition", contentDisposition.toString());
        if (headers !== null && headers !== undefined)
            content_.append("Headers", headers.toString());
        if (length !== null && length !== undefined)
            content_.append("Length", length.toString());
        if (name !== null && name !== undefined)
            content_.append("Name", name.toString());
        if (fileName !== null && fileName !== undefined)
            content_.append("FileName", fileName.toString());

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFileUploadPost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFileUploadPost(<any>response_);
                } catch (e) {
                    return <Observable<ApiResultOfIFormFile>><any>_observableThrow(e);
                }
            } else
                return <Observable<ApiResultOfIFormFile>><any>_observableThrow(response_);
        }));
    }

    protected processFileUploadPost(response: HttpResponseBase): Observable<ApiResultOfIFormFile> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApiResultOfIFormFile.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ApiResultOfIFormFile.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApiResultOfIFormFile>(<any>null);
    }

    /**
     * @return Success
     */
    fileUploadDeleteWithid(id: string): Observable<ApiResultOfString> {
        let url_ = this.baseUrl + "/v1/file-upload/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFileUploadDeleteWithid(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFileUploadDeleteWithid(<any>response_);
                } catch (e) {
                    return <Observable<ApiResultOfString>><any>_observableThrow(e);
                }
            } else
                return <Observable<ApiResultOfString>><any>_observableThrow(response_);
        }));
    }

    protected processFileUploadDeleteWithid(response: HttpResponseBase): Observable<ApiResultOfString> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApiResultOfString.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ApiResultOfString.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApiResultOfString>(<any>null);
    }
}

@Injectable()
export class GameAccountService {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "/api";
    }

    /**
     * @return Success
     */
    gameAccountGet(): Observable<ApiResultOfIPagedListOfGameAccountViewModel> {
        let url_ = this.baseUrl + "/v1/game-account";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGameAccountGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGameAccountGet(<any>response_);
                } catch (e) {
                    return <Observable<ApiResultOfIPagedListOfGameAccountViewModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<ApiResultOfIPagedListOfGameAccountViewModel>><any>_observableThrow(response_);
        }));
    }

    protected processGameAccountGet(response: HttpResponseBase): Observable<ApiResultOfIPagedListOfGameAccountViewModel> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApiResultOfIPagedListOfGameAccountViewModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApiResultOfIPagedListOfGameAccountViewModel>(<any>null);
    }

    /**
     * @param gameAccountViewModel (optional) 
     * @return Success
     */
    gameAccountPost(gameAccountViewModel: GameAccountViewModel | null | undefined): Observable<ApiResultOfGameAccountViewModel> {
        let url_ = this.baseUrl + "/v1/game-account";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(gameAccountViewModel);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGameAccountPost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGameAccountPost(<any>response_);
                } catch (e) {
                    return <Observable<ApiResultOfGameAccountViewModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<ApiResultOfGameAccountViewModel>><any>_observableThrow(response_);
        }));
    }

    protected processGameAccountPost(response: HttpResponseBase): Observable<ApiResultOfGameAccountViewModel> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApiResultOfGameAccountViewModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ApiResultOfGameAccountViewModel.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApiResultOfGameAccountViewModel>(<any>null);
    }

    /**
     * @param gameAccountViewModel (optional) 
     * @return Success
     */
    gameAccountPatch(gameAccountViewModel: GameAccountViewModel | null | undefined): Observable<ApiResultOfGameAccountViewModel> {
        let url_ = this.baseUrl + "/v1/game-account";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(gameAccountViewModel);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("patch", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGameAccountPatch(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGameAccountPatch(<any>response_);
                } catch (e) {
                    return <Observable<ApiResultOfGameAccountViewModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<ApiResultOfGameAccountViewModel>><any>_observableThrow(response_);
        }));
    }

    protected processGameAccountPatch(response: HttpResponseBase): Observable<ApiResultOfGameAccountViewModel> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApiResultOfGameAccountViewModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ApiResultOfGameAccountViewModel.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApiResultOfGameAccountViewModel>(<any>null);
    }

    /**
     * @return Success
     */
    gameAccountGetByid(id: string): Observable<ApiResultOfIPagedListOfGameAccountViewModel> {
        let url_ = this.baseUrl + "/v1/game-account/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGameAccountGetByid(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGameAccountGetByid(<any>response_);
                } catch (e) {
                    return <Observable<ApiResultOfIPagedListOfGameAccountViewModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<ApiResultOfIPagedListOfGameAccountViewModel>><any>_observableThrow(response_);
        }));
    }

    protected processGameAccountGetByid(response: HttpResponseBase): Observable<ApiResultOfIPagedListOfGameAccountViewModel> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApiResultOfIPagedListOfGameAccountViewModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApiResultOfIPagedListOfGameAccountViewModel>(<any>null);
    }
}

@Injectable()
export class GameCharacterService {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "/api";
    }

    /**
     * @param id (optional) 
     * @param index (optional) 
     * @param count (optional) 
     * @param searchText (optional) 
     * @return Success
     */
    gameCharacterGet(id: string | null | undefined, index: number | null | undefined, count: number | null | undefined, searchText: string | null | undefined): Observable<ApiResultOfPagedResultDataOfIEnumerableOfCharacterAdminViewModel> {
        let url_ = this.baseUrl + "/v1/game-character?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        if (index !== undefined)
            url_ += "index=" + encodeURIComponent("" + index) + "&"; 
        if (count !== undefined)
            url_ += "count=" + encodeURIComponent("" + count) + "&"; 
        if (searchText !== undefined)
            url_ += "searchText=" + encodeURIComponent("" + searchText) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGameCharacterGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGameCharacterGet(<any>response_);
                } catch (e) {
                    return <Observable<ApiResultOfPagedResultDataOfIEnumerableOfCharacterAdminViewModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<ApiResultOfPagedResultDataOfIEnumerableOfCharacterAdminViewModel>><any>_observableThrow(response_);
        }));
    }

    protected processGameCharacterGet(response: HttpResponseBase): Observable<ApiResultOfPagedResultDataOfIEnumerableOfCharacterAdminViewModel> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApiResultOfPagedResultDataOfIEnumerableOfCharacterAdminViewModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ApiResultOfPagedResultDataOfIEnumerableOfCharacterAdminViewModel.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApiResultOfPagedResultDataOfIEnumerableOfCharacterAdminViewModel>(<any>null);
    }

    /**
     * @param models (optional) 
     * @return Success
     */
    gameCharacterPost(models: CharacterAdminViewModel[] | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/v1/game-character";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(models);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGameCharacterPost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGameCharacterPost(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processGameCharacterPost(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    myCharacters(): Observable<ApiResultOfIEnumerableOfCharacterViewModel> {
        let url_ = this.baseUrl + "/v1/game-character/my-characters";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMyCharacters(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMyCharacters(<any>response_);
                } catch (e) {
                    return <Observable<ApiResultOfIEnumerableOfCharacterViewModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<ApiResultOfIEnumerableOfCharacterViewModel>><any>_observableThrow(response_);
        }));
    }

    protected processMyCharacters(response: HttpResponseBase): Observable<ApiResultOfIEnumerableOfCharacterViewModel> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApiResultOfIEnumerableOfCharacterViewModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ApiResultOfIEnumerableOfCharacterViewModel.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApiResultOfIEnumerableOfCharacterViewModel>(<any>null);
    }
}

@Injectable()
export class GameEventService {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "/api";
    }

    /**
     * @return Success
     */
    gameEventsGet(): Observable<ApiResultOfIListOfStoredEvent> {
        let url_ = this.baseUrl + "/v1/game-events";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGameEventsGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGameEventsGet(<any>response_);
                } catch (e) {
                    return <Observable<ApiResultOfIListOfStoredEvent>><any>_observableThrow(e);
                }
            } else
                return <Observable<ApiResultOfIListOfStoredEvent>><any>_observableThrow(response_);
        }));
    }

    protected processGameEventsGet(response: HttpResponseBase): Observable<ApiResultOfIListOfStoredEvent> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApiResultOfIListOfStoredEvent.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApiResultOfIListOfStoredEvent>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    gameEventsPatch(id: string | null | undefined): Observable<ApiResultOfGuid> {
        let url_ = this.baseUrl + "/v1/game-events";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(id);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("patch", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGameEventsPatch(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGameEventsPatch(<any>response_);
                } catch (e) {
                    return <Observable<ApiResultOfGuid>><any>_observableThrow(e);
                }
            } else
                return <Observable<ApiResultOfGuid>><any>_observableThrow(response_);
        }));
    }

    protected processGameEventsPatch(response: HttpResponseBase): Observable<ApiResultOfGuid> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApiResultOfGuid.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApiResultOfGuid>(<any>null);
    }
}

@Injectable()
export class GenericService {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "/api";
    }

    /**
     * @param type (optional) 
     * @param amount (optional) 
     * @return Success
     */
    generalGet(type: string | null | undefined, amount: number | null | undefined): Observable<ApiResultOfIEnumerableOfGenericObjectViewModel> {
        let url_ = this.baseUrl + "/v1/general?";
        if (type !== undefined)
            url_ += "type=" + encodeURIComponent("" + type) + "&"; 
        if (amount !== undefined)
            url_ += "amount=" + encodeURIComponent("" + amount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGeneralGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGeneralGet(<any>response_);
                } catch (e) {
                    return <Observable<ApiResultOfIEnumerableOfGenericObjectViewModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<ApiResultOfIEnumerableOfGenericObjectViewModel>><any>_observableThrow(response_);
        }));
    }

    protected processGeneralGet(response: HttpResponseBase): Observable<ApiResultOfIEnumerableOfGenericObjectViewModel> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApiResultOfIEnumerableOfGenericObjectViewModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ApiResultOfIEnumerableOfGenericObjectViewModel.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApiResultOfIEnumerableOfGenericObjectViewModel>(<any>null);
    }

    /**
     * @param model (optional) 
     * @return Success
     */
    generalPost(model: GenericObjectViewModel | null | undefined): Observable<ApiResultOfGenericObjectViewModel> {
        let url_ = this.baseUrl + "/v1/general";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGeneralPost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGeneralPost(<any>response_);
                } catch (e) {
                    return <Observable<ApiResultOfGenericObjectViewModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<ApiResultOfGenericObjectViewModel>><any>_observableThrow(response_);
        }));
    }

    protected processGeneralPost(response: HttpResponseBase): Observable<ApiResultOfGenericObjectViewModel> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApiResultOfGenericObjectViewModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ApiResultOfGenericObjectViewModel.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApiResultOfGenericObjectViewModel>(<any>null);
    }

    /**
     * @param model (optional) 
     * @return Success
     */
    generalPatch(model: GenericObjectViewModel | null | undefined): Observable<ApiResultOfGenericObjectViewModel> {
        let url_ = this.baseUrl + "/v1/general";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("patch", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGeneralPatch(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGeneralPatch(<any>response_);
                } catch (e) {
                    return <Observable<ApiResultOfGenericObjectViewModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<ApiResultOfGenericObjectViewModel>><any>_observableThrow(response_);
        }));
    }

    protected processGeneralPatch(response: HttpResponseBase): Observable<ApiResultOfGenericObjectViewModel> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApiResultOfGenericObjectViewModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ApiResultOfGenericObjectViewModel.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApiResultOfGenericObjectViewModel>(<any>null);
    }

    /**
     * @return Success
     */
    generalDeleteWithid(id: string): Observable<ApiResultOfString> {
        let url_ = this.baseUrl + "/v1/general/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGeneralDeleteWithid(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGeneralDeleteWithid(<any>response_);
                } catch (e) {
                    return <Observable<ApiResultOfString>><any>_observableThrow(e);
                }
            } else
                return <Observable<ApiResultOfString>><any>_observableThrow(response_);
        }));
    }

    protected processGeneralDeleteWithid(response: HttpResponseBase): Observable<ApiResultOfString> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApiResultOfString.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ApiResultOfString.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApiResultOfString>(<any>null);
    }
}

@Injectable()
export class NewsService {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "/api";
    }

    /**
     * @param index (optional) 
     * @param count (optional) 
     * @return Success
     */
    unpublished(index: number | null | undefined, count: number | null | undefined): Observable<ApiResultOfPagedResultDataOfIEnumerableOfNewsPostViewModel> {
        let url_ = this.baseUrl + "/v1/news/unpublished?";
        if (index !== undefined)
            url_ += "index=" + encodeURIComponent("" + index) + "&"; 
        if (count !== undefined)
            url_ += "count=" + encodeURIComponent("" + count) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUnpublished(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUnpublished(<any>response_);
                } catch (e) {
                    return <Observable<ApiResultOfPagedResultDataOfIEnumerableOfNewsPostViewModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<ApiResultOfPagedResultDataOfIEnumerableOfNewsPostViewModel>><any>_observableThrow(response_);
        }));
    }

    protected processUnpublished(response: HttpResponseBase): Observable<ApiResultOfPagedResultDataOfIEnumerableOfNewsPostViewModel> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApiResultOfPagedResultDataOfIEnumerableOfNewsPostViewModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApiResultOfPagedResultDataOfIEnumerableOfNewsPostViewModel>(<any>null);
    }

    /**
     * @param index (optional) 
     * @param count (optional) 
     * @return Success
     */
    newsGet(index: number | null | undefined, count: number | null | undefined): Observable<ApiResultOfPagedResultDataOfIEnumerableOfNewsPostViewModel> {
        let url_ = this.baseUrl + "/v1/news?";
        if (index !== undefined)
            url_ += "index=" + encodeURIComponent("" + index) + "&"; 
        if (count !== undefined)
            url_ += "count=" + encodeURIComponent("" + count) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processNewsGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processNewsGet(<any>response_);
                } catch (e) {
                    return <Observable<ApiResultOfPagedResultDataOfIEnumerableOfNewsPostViewModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<ApiResultOfPagedResultDataOfIEnumerableOfNewsPostViewModel>><any>_observableThrow(response_);
        }));
    }

    protected processNewsGet(response: HttpResponseBase): Observable<ApiResultOfPagedResultDataOfIEnumerableOfNewsPostViewModel> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApiResultOfPagedResultDataOfIEnumerableOfNewsPostViewModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApiResultOfPagedResultDataOfIEnumerableOfNewsPostViewModel>(<any>null);
    }

    /**
     * @param newsViewModel (optional) 
     * @return Success
     */
    newsPost(newsViewModel: NewsPostViewModel | null | undefined): Observable<ApiResultOfNewsPostViewModel> {
        let url_ = this.baseUrl + "/v1/news";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(newsViewModel);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processNewsPost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processNewsPost(<any>response_);
                } catch (e) {
                    return <Observable<ApiResultOfNewsPostViewModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<ApiResultOfNewsPostViewModel>><any>_observableThrow(response_);
        }));
    }

    protected processNewsPost(response: HttpResponseBase): Observable<ApiResultOfNewsPostViewModel> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApiResultOfNewsPostViewModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ApiResultOfNewsPostViewModel.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApiResultOfNewsPostViewModel>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    newsDelete(id: string | null | undefined): Observable<ApiResultOfGuid> {
        let url_ = this.baseUrl + "/v1/news?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processNewsDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processNewsDelete(<any>response_);
                } catch (e) {
                    return <Observable<ApiResultOfGuid>><any>_observableThrow(e);
                }
            } else
                return <Observable<ApiResultOfGuid>><any>_observableThrow(response_);
        }));
    }

    protected processNewsDelete(response: HttpResponseBase): Observable<ApiResultOfGuid> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApiResultOfGuid.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ApiResultOfGuid.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApiResultOfGuid>(<any>null);
    }

    /**
     * @param newsViewModel (optional) 
     * @return Success
     */
    newsPatch(newsViewModel: NewsPostViewModel | null | undefined): Observable<ApiResultOfNewsPostViewModel> {
        let url_ = this.baseUrl + "/v1/news";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(newsViewModel);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("patch", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processNewsPatch(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processNewsPatch(<any>response_);
                } catch (e) {
                    return <Observable<ApiResultOfNewsPostViewModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<ApiResultOfNewsPostViewModel>><any>_observableThrow(response_);
        }));
    }

    protected processNewsPatch(response: HttpResponseBase): Observable<ApiResultOfNewsPostViewModel> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApiResultOfNewsPostViewModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ApiResultOfNewsPostViewModel.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApiResultOfNewsPostViewModel>(<any>null);
    }

    /**
     * @return Success
     */
    newsGetByid(id: string): Observable<ApiResultOfNewsPostViewModel> {
        let url_ = this.baseUrl + "/v1/news/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processNewsGetByid(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processNewsGetByid(<any>response_);
                } catch (e) {
                    return <Observable<ApiResultOfNewsPostViewModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<ApiResultOfNewsPostViewModel>><any>_observableThrow(response_);
        }));
    }

    protected processNewsGetByid(response: HttpResponseBase): Observable<ApiResultOfNewsPostViewModel> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApiResultOfNewsPostViewModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApiResultOfNewsPostViewModel>(<any>null);
    }
}

@Injectable()
export class PlayerLogService {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "/api";
    }

    /**
     * @param object (optional) 
     * @return Success
     */
    logPlayer(object: any | null | undefined): Observable<ApiResultOfBoolean> {
        let url_ = this.baseUrl + "/v1/log-player";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(object);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processLogPlayer(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLogPlayer(<any>response_);
                } catch (e) {
                    return <Observable<ApiResultOfBoolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<ApiResultOfBoolean>><any>_observableThrow(response_);
        }));
    }

    protected processLogPlayer(response: HttpResponseBase): Observable<ApiResultOfBoolean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApiResultOfBoolean.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ApiResultOfBoolean.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApiResultOfBoolean>(<any>null);
    }
}

@Injectable()
export class RankingService {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "/api";
    }

    /**
     * @param index (optional) 
     * @param count (optional) 
     * @param orderBy (optional) 
     * @param job (optional) 
     * @return Success
     */
    ranking(index: number | null | undefined, count: number | null | undefined, orderBy: string | null | undefined, job: string | null | undefined): Observable<ApiResultOfPagedResultDataOfIEnumerableOfCharacterViewModel> {
        let url_ = this.baseUrl + "/v1/ranking?";
        if (index !== undefined)
            url_ += "index=" + encodeURIComponent("" + index) + "&"; 
        if (count !== undefined)
            url_ += "count=" + encodeURIComponent("" + count) + "&"; 
        if (orderBy !== undefined)
            url_ += "orderBy=" + encodeURIComponent("" + orderBy) + "&"; 
        if (job !== undefined)
            url_ += "job=" + encodeURIComponent("" + job) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRanking(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRanking(<any>response_);
                } catch (e) {
                    return <Observable<ApiResultOfPagedResultDataOfIEnumerableOfCharacterViewModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<ApiResultOfPagedResultDataOfIEnumerableOfCharacterViewModel>><any>_observableThrow(response_);
        }));
    }

    protected processRanking(response: HttpResponseBase): Observable<ApiResultOfPagedResultDataOfIEnumerableOfCharacterViewModel> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApiResultOfPagedResultDataOfIEnumerableOfCharacterViewModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ApiResultOfPagedResultDataOfIEnumerableOfCharacterViewModel.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApiResultOfPagedResultDataOfIEnumerableOfCharacterViewModel>(<any>null);
    }
}

@Injectable()
export class RolesService {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "/api";
    }

    /**
     * @return Success
     */
    rolesGetByid(id: string): Observable<ApiResultOfStringOf> {
        let url_ = this.baseUrl + "/v1/roles/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRolesGetByid(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRolesGetByid(<any>response_);
                } catch (e) {
                    return <Observable<ApiResultOfStringOf>><any>_observableThrow(e);
                }
            } else
                return <Observable<ApiResultOfStringOf>><any>_observableThrow(response_);
        }));
    }

    protected processRolesGetByid(response: HttpResponseBase): Observable<ApiResultOfStringOf> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApiResultOfStringOf.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ApiResultOfStringOf.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApiResultOfStringOf>(<any>null);
    }

    /**
     * @param rolesViewModel (optional) 
     * @return Success
     */
    roles(rolesViewModel: UpdateRolesViewModel | null | undefined): Observable<ApiResultOfUpdateRolesViewModel> {
        let url_ = this.baseUrl + "/v1/roles";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(rolesViewModel);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("patch", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRoles(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRoles(<any>response_);
                } catch (e) {
                    return <Observable<ApiResultOfUpdateRolesViewModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<ApiResultOfUpdateRolesViewModel>><any>_observableThrow(response_);
        }));
    }

    protected processRoles(response: HttpResponseBase): Observable<ApiResultOfUpdateRolesViewModel> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApiResultOfUpdateRolesViewModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ApiResultOfUpdateRolesViewModel.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApiResultOfUpdateRolesViewModel>(<any>null);
    }
}

@Injectable()
export class ServiceStatusService {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "/api";
    }

    /**
     * @return Success
     */
    recentHidden(): Observable<ApiResultOfIEnumerableOfServiceStatusViewModel> {
        let url_ = this.baseUrl + "/v1/service-status/recent-hidden";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRecentHidden(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRecentHidden(<any>response_);
                } catch (e) {
                    return <Observable<ApiResultOfIEnumerableOfServiceStatusViewModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<ApiResultOfIEnumerableOfServiceStatusViewModel>><any>_observableThrow(response_);
        }));
    }

    protected processRecentHidden(response: HttpResponseBase): Observable<ApiResultOfIEnumerableOfServiceStatusViewModel> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApiResultOfIEnumerableOfServiceStatusViewModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApiResultOfIEnumerableOfServiceStatusViewModel>(<any>null);
    }

    /**
     * @return Success
     */
    serviceStatusGet(): Observable<ApiResultOfIEnumerableOfServiceStatusViewModel> {
        let url_ = this.baseUrl + "/v1/service-status";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processServiceStatusGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processServiceStatusGet(<any>response_);
                } catch (e) {
                    return <Observable<ApiResultOfIEnumerableOfServiceStatusViewModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<ApiResultOfIEnumerableOfServiceStatusViewModel>><any>_observableThrow(response_);
        }));
    }

    protected processServiceStatusGet(response: HttpResponseBase): Observable<ApiResultOfIEnumerableOfServiceStatusViewModel> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApiResultOfIEnumerableOfServiceStatusViewModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApiResultOfIEnumerableOfServiceStatusViewModel>(<any>null);
    }

    /**
     * @param model (optional) 
     * @return Success
     */
    serviceStatusPost(model: ServiceStatusViewModel | null | undefined): Observable<ApiResultOfServiceStatusViewModel> {
        let url_ = this.baseUrl + "/v1/service-status";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processServiceStatusPost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processServiceStatusPost(<any>response_);
                } catch (e) {
                    return <Observable<ApiResultOfServiceStatusViewModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<ApiResultOfServiceStatusViewModel>><any>_observableThrow(response_);
        }));
    }

    protected processServiceStatusPost(response: HttpResponseBase): Observable<ApiResultOfServiceStatusViewModel> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApiResultOfServiceStatusViewModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ApiResultOfServiceStatusViewModel.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApiResultOfServiceStatusViewModel>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    serviceStatusDelete(id: string | null | undefined): Observable<string> {
        let url_ = this.baseUrl + "/v1/service-status?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processServiceStatusDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processServiceStatusDelete(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processServiceStatusDelete(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }

    /**
     * @param model (optional) 
     * @return Success
     */
    serviceStatusPatch(model: ServiceStatusViewModel | null | undefined): Observable<ApiResultOfServiceStatusViewModel> {
        let url_ = this.baseUrl + "/v1/service-status";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("patch", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processServiceStatusPatch(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processServiceStatusPatch(<any>response_);
                } catch (e) {
                    return <Observable<ApiResultOfServiceStatusViewModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<ApiResultOfServiceStatusViewModel>><any>_observableThrow(response_);
        }));
    }

    protected processServiceStatusPatch(response: HttpResponseBase): Observable<ApiResultOfServiceStatusViewModel> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApiResultOfServiceStatusViewModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ApiResultOfServiceStatusViewModel.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApiResultOfServiceStatusViewModel>(<any>null);
    }
}

@Injectable()
export class StatisticsService {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "/api";
    }

    /**
     * @param from (optional) 
     * @param until (optional) 
     * @param statGroup (optional) 
     * @param statName (optional) 
     * @param interval (optional) 
     * @return Success
     */
    statisticsGet(from: string | null | undefined, until: string | null | undefined, statGroup: string | null | undefined, statName: string | null | undefined, interval: string | null | undefined): Observable<ApiResultOfIEnumerableOfStatisticsEntryViewModel> {
        let url_ = this.baseUrl + "/v1/statistics?";
        if (from !== undefined)
            url_ += "from=" + encodeURIComponent("" + from) + "&"; 
        if (until !== undefined)
            url_ += "until=" + encodeURIComponent("" + until) + "&"; 
        if (statGroup !== undefined)
            url_ += "statGroup=" + encodeURIComponent("" + statGroup) + "&"; 
        if (statName !== undefined)
            url_ += "statName=" + encodeURIComponent("" + statName) + "&"; 
        if (interval !== undefined)
            url_ += "interval=" + encodeURIComponent("" + interval) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processStatisticsGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processStatisticsGet(<any>response_);
                } catch (e) {
                    return <Observable<ApiResultOfIEnumerableOfStatisticsEntryViewModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<ApiResultOfIEnumerableOfStatisticsEntryViewModel>><any>_observableThrow(response_);
        }));
    }

    protected processStatisticsGet(response: HttpResponseBase): Observable<ApiResultOfIEnumerableOfStatisticsEntryViewModel> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApiResultOfIEnumerableOfStatisticsEntryViewModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ApiResultOfIEnumerableOfStatisticsEntryViewModel.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApiResultOfIEnumerableOfStatisticsEntryViewModel>(<any>null);
    }

    /**
     * @param model (optional) 
     * @return Success
     */
    statisticsPost(model: StatisticsEntryViewModel | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/v1/statistics";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processStatisticsPost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processStatisticsPost(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processStatisticsPost(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class TransactionsService {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "/api";
    }

    /**
     * @return Success
     */
    transactionsGet(): Observable<ApiResultOfIEnumerableOfTransactionViewModel> {
        let url_ = this.baseUrl + "/v1/transactions";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTransactionsGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTransactionsGet(<any>response_);
                } catch (e) {
                    return <Observable<ApiResultOfIEnumerableOfTransactionViewModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<ApiResultOfIEnumerableOfTransactionViewModel>><any>_observableThrow(response_);
        }));
    }

    protected processTransactionsGet(response: HttpResponseBase): Observable<ApiResultOfIEnumerableOfTransactionViewModel> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApiResultOfIEnumerableOfTransactionViewModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApiResultOfIEnumerableOfTransactionViewModel>(<any>null);
    }

    /**
     * @param viewModel (optional) 
     * @return Success
     */
    transactionsPatch(viewModel: TransactionViewModel | null | undefined): Observable<ApiResultOfTransactionViewModel> {
        let url_ = this.baseUrl + "/v1/transactions";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(viewModel);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("patch", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTransactionsPatch(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTransactionsPatch(<any>response_);
                } catch (e) {
                    return <Observable<ApiResultOfTransactionViewModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<ApiResultOfTransactionViewModel>><any>_observableThrow(response_);
        }));
    }

    protected processTransactionsPatch(response: HttpResponseBase): Observable<ApiResultOfTransactionViewModel> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApiResultOfTransactionViewModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApiResultOfTransactionViewModel>(<any>null);
    }

    /**
     * @param viewModel (optional) 
     * @return Success
     */
    withdraw(viewModel: WithdrawCurrencyViewModel | null | undefined): Observable<ApiResultOfWithdrawCurrencyViewModel> {
        let url_ = this.baseUrl + "/v1/transactions/withdraw";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(viewModel);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processWithdraw(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processWithdraw(<any>response_);
                } catch (e) {
                    return <Observable<ApiResultOfWithdrawCurrencyViewModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<ApiResultOfWithdrawCurrencyViewModel>><any>_observableThrow(response_);
        }));
    }

    protected processWithdraw(response: HttpResponseBase): Observable<ApiResultOfWithdrawCurrencyViewModel> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApiResultOfWithdrawCurrencyViewModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApiResultOfWithdrawCurrencyViewModel>(<any>null);
    }
}

@Injectable()
export class VoteService {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "/api";
    }

    /**
     * @param voterIP (optional) 
     * @param successful (optional) 
     * @param reason (optional) 
     * @param pingUsername (optional) 
     * @return Success
     */
    pingback(voterIP: string | null | undefined, successful: string | null | undefined, reason: string | null | undefined, pingUsername: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/v1/vote/pingback?";
        if (voterIP !== undefined)
            url_ += "VoterIP=" + encodeURIComponent("" + voterIP) + "&"; 
        if (successful !== undefined)
            url_ += "Successful=" + encodeURIComponent("" + successful) + "&"; 
        if (reason !== undefined)
            url_ += "Reason=" + encodeURIComponent("" + reason) + "&"; 
        if (pingUsername !== undefined)
            url_ += "pingUsername=" + encodeURIComponent("" + pingUsername) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPingback(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPingback(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processPingback(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param index (optional) 
     * @param count (optional) 
     * @return Success
     */
    vote(index: number | null | undefined, count: number | null | undefined): Observable<ApiResultOfPagedResultDataOfIEnumerableOfTransactionViewModel> {
        let url_ = this.baseUrl + "/v1/vote?";
        if (index !== undefined)
            url_ += "index=" + encodeURIComponent("" + index) + "&"; 
        if (count !== undefined)
            url_ += "count=" + encodeURIComponent("" + count) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processVote(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processVote(<any>response_);
                } catch (e) {
                    return <Observable<ApiResultOfPagedResultDataOfIEnumerableOfTransactionViewModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<ApiResultOfPagedResultDataOfIEnumerableOfTransactionViewModel>><any>_observableThrow(response_);
        }));
    }

    protected processVote(response: HttpResponseBase): Observable<ApiResultOfPagedResultDataOfIEnumerableOfTransactionViewModel> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApiResultOfPagedResultDataOfIEnumerableOfTransactionViewModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApiResultOfPagedResultDataOfIEnumerableOfTransactionViewModel>(<any>null);
    }

    /**
     * @return Success
     */
    balance(): Observable<ApiResultOfInt32> {
        let url_ = this.baseUrl + "/v1/vote/balance";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBalance(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBalance(<any>response_);
                } catch (e) {
                    return <Observable<ApiResultOfInt32>><any>_observableThrow(e);
                }
            } else
                return <Observable<ApiResultOfInt32>><any>_observableThrow(response_);
        }));
    }

    protected processBalance(response: HttpResponseBase): Observable<ApiResultOfInt32> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApiResultOfInt32.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApiResultOfInt32>(<any>null);
    }

    /**
     * @return Success
     */
    status(): Observable<ApiResultOfVoteState> {
        let url_ = this.baseUrl + "/v1/vote/status";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processStatus(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processStatus(<any>response_);
                } catch (e) {
                    return <Observable<ApiResultOfVoteState>><any>_observableThrow(e);
                }
            } else
                return <Observable<ApiResultOfVoteState>><any>_observableThrow(response_);
        }));
    }

    protected processStatus(response: HttpResponseBase): Observable<ApiResultOfVoteState> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApiResultOfVoteState.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApiResultOfVoteState>(<any>null);
    }
}

export class LoginViewModel implements ILoginViewModel {
    email!: string;
    password!: string;
    rememberMe?: boolean | undefined;

    constructor(data?: ILoginViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.email = _data["email"];
            this.password = _data["password"];
            this.rememberMe = _data["rememberMe"];
        }
    }

    static fromJS(data: any): LoginViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new LoginViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["email"] = this.email;
        data["password"] = this.password;
        data["rememberMe"] = this.rememberMe;
        return data; 
    }
}

export interface ILoginViewModel {
    email: string;
    password: string;
    rememberMe?: boolean | undefined;
}

export class ApiResultOfString implements IApiResultOfString {
    readonly data?: string | undefined;
    readonly success?: boolean | undefined;
    readonly errors?: string[] | undefined;

    constructor(data?: IApiResultOfString) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).data = _data["data"];
            (<any>this).success = _data["success"];
            if (Array.isArray(_data["errors"])) {
                (<any>this).errors = [] as any;
                for (let item of _data["errors"])
                    (<any>this).errors!.push(item);
            }
        }
    }

    static fromJS(data: any): ApiResultOfString {
        data = typeof data === 'object' ? data : {};
        let result = new ApiResultOfString();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data"] = this.data;
        data["success"] = this.success;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        return data; 
    }
}

export interface IApiResultOfString {
    data?: string | undefined;
    success?: boolean | undefined;
    errors?: string[] | undefined;
}

export class ApiResultOfLoginViewModel implements IApiResultOfLoginViewModel {
    readonly data?: LoginViewModel | undefined;
    readonly success?: boolean | undefined;
    readonly errors?: string[] | undefined;

    constructor(data?: IApiResultOfLoginViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).data = _data["data"] ? LoginViewModel.fromJS(_data["data"]) : <any>undefined;
            (<any>this).success = _data["success"];
            if (Array.isArray(_data["errors"])) {
                (<any>this).errors = [] as any;
                for (let item of _data["errors"])
                    (<any>this).errors!.push(item);
            }
        }
    }

    static fromJS(data: any): ApiResultOfLoginViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new ApiResultOfLoginViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["success"] = this.success;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        return data; 
    }
}

export interface IApiResultOfLoginViewModel {
    data?: LoginViewModel | undefined;
    success?: boolean | undefined;
    errors?: string[] | undefined;
}

export class RegisterViewModel implements IRegisterViewModel {
    email!: string;
    password!: string;
    confirmPassword?: string | undefined;

    constructor(data?: IRegisterViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.email = _data["email"];
            this.password = _data["password"];
            this.confirmPassword = _data["confirmPassword"];
        }
    }

    static fromJS(data: any): RegisterViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new RegisterViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["email"] = this.email;
        data["password"] = this.password;
        data["confirmPassword"] = this.confirmPassword;
        return data; 
    }
}

export interface IRegisterViewModel {
    email: string;
    password: string;
    confirmPassword?: string | undefined;
}

export class ApiResultOfRegisterViewModel implements IApiResultOfRegisterViewModel {
    readonly data?: RegisterViewModel | undefined;
    readonly success?: boolean | undefined;
    readonly errors?: string[] | undefined;

    constructor(data?: IApiResultOfRegisterViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).data = _data["data"] ? RegisterViewModel.fromJS(_data["data"]) : <any>undefined;
            (<any>this).success = _data["success"];
            if (Array.isArray(_data["errors"])) {
                (<any>this).errors = [] as any;
                for (let item of _data["errors"])
                    (<any>this).errors!.push(item);
            }
        }
    }

    static fromJS(data: any): ApiResultOfRegisterViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new ApiResultOfRegisterViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["success"] = this.success;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        return data; 
    }
}

export interface IApiResultOfRegisterViewModel {
    data?: RegisterViewModel | undefined;
    success?: boolean | undefined;
    errors?: string[] | undefined;
}

export class ApiResultOfPagedResultDataOfIEnumerableOfApplicationUser implements IApiResultOfPagedResultDataOfIEnumerableOfApplicationUser {
    readonly data?: PagedResultDataOfIEnumerableOfApplicationUser | undefined;
    readonly success?: boolean | undefined;
    readonly errors?: string[] | undefined;

    constructor(data?: IApiResultOfPagedResultDataOfIEnumerableOfApplicationUser) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).data = _data["data"] ? PagedResultDataOfIEnumerableOfApplicationUser.fromJS(_data["data"]) : <any>undefined;
            (<any>this).success = _data["success"];
            if (Array.isArray(_data["errors"])) {
                (<any>this).errors = [] as any;
                for (let item of _data["errors"])
                    (<any>this).errors!.push(item);
            }
        }
    }

    static fromJS(data: any): ApiResultOfPagedResultDataOfIEnumerableOfApplicationUser {
        data = typeof data === 'object' ? data : {};
        let result = new ApiResultOfPagedResultDataOfIEnumerableOfApplicationUser();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["success"] = this.success;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        return data; 
    }
}

export interface IApiResultOfPagedResultDataOfIEnumerableOfApplicationUser {
    data?: PagedResultDataOfIEnumerableOfApplicationUser | undefined;
    success?: boolean | undefined;
    errors?: string[] | undefined;
}

export class PagedResultDataOfIEnumerableOfApplicationUser implements IPagedResultDataOfIEnumerableOfApplicationUser {
    readonly content?: ApplicationUser[] | undefined;
    readonly recordCount?: number | undefined;
    readonly currentIndex?: number | undefined;
    readonly currentCountPerPage?: number | undefined;
    readonly pageCount?: number | undefined;

    constructor(data?: IPagedResultDataOfIEnumerableOfApplicationUser) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["content"])) {
                (<any>this).content = [] as any;
                for (let item of _data["content"])
                    (<any>this).content!.push(ApplicationUser.fromJS(item));
            }
            (<any>this).recordCount = _data["recordCount"];
            (<any>this).currentIndex = _data["currentIndex"];
            (<any>this).currentCountPerPage = _data["currentCountPerPage"];
            (<any>this).pageCount = _data["pageCount"];
        }
    }

    static fromJS(data: any): PagedResultDataOfIEnumerableOfApplicationUser {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDataOfIEnumerableOfApplicationUser();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.content)) {
            data["content"] = [];
            for (let item of this.content)
                data["content"].push(item.toJSON());
        }
        data["recordCount"] = this.recordCount;
        data["currentIndex"] = this.currentIndex;
        data["currentCountPerPage"] = this.currentCountPerPage;
        data["pageCount"] = this.pageCount;
        return data; 
    }
}

export interface IPagedResultDataOfIEnumerableOfApplicationUser {
    content?: ApplicationUser[] | undefined;
    recordCount?: number | undefined;
    currentIndex?: number | undefined;
    currentCountPerPage?: number | undefined;
    pageCount?: number | undefined;
}

export class ApplicationUser implements IApplicationUser {
    id?: string | undefined;
    userName?: string | undefined;
    normalizedUserName?: string | undefined;
    email?: string | undefined;
    normalizedEmail?: string | undefined;
    emailConfirmed?: boolean | undefined;
    passwordHash?: string | undefined;
    securityStamp?: string | undefined;
    concurrencyStamp?: string | undefined;
    phoneNumber?: string | undefined;
    phoneNumberConfirmed?: boolean | undefined;
    twoFactorEnabled?: boolean | undefined;
    lockoutEnd?: Date | undefined;
    lockoutEnabled?: boolean | undefined;
    accessFailedCount?: number | undefined;

    constructor(data?: IApplicationUser) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.userName = _data["userName"];
            this.normalizedUserName = _data["normalizedUserName"];
            this.email = _data["email"];
            this.normalizedEmail = _data["normalizedEmail"];
            this.emailConfirmed = _data["emailConfirmed"];
            this.passwordHash = _data["passwordHash"];
            this.securityStamp = _data["securityStamp"];
            this.concurrencyStamp = _data["concurrencyStamp"];
            this.phoneNumber = _data["phoneNumber"];
            this.phoneNumberConfirmed = _data["phoneNumberConfirmed"];
            this.twoFactorEnabled = _data["twoFactorEnabled"];
            this.lockoutEnd = _data["lockoutEnd"] ? new Date(_data["lockoutEnd"].toString()) : <any>undefined;
            this.lockoutEnabled = _data["lockoutEnabled"];
            this.accessFailedCount = _data["accessFailedCount"];
        }
    }

    static fromJS(data: any): ApplicationUser {
        data = typeof data === 'object' ? data : {};
        let result = new ApplicationUser();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["userName"] = this.userName;
        data["normalizedUserName"] = this.normalizedUserName;
        data["email"] = this.email;
        data["normalizedEmail"] = this.normalizedEmail;
        data["emailConfirmed"] = this.emailConfirmed;
        data["passwordHash"] = this.passwordHash;
        data["securityStamp"] = this.securityStamp;
        data["concurrencyStamp"] = this.concurrencyStamp;
        data["phoneNumber"] = this.phoneNumber;
        data["phoneNumberConfirmed"] = this.phoneNumberConfirmed;
        data["twoFactorEnabled"] = this.twoFactorEnabled;
        data["lockoutEnd"] = this.lockoutEnd ? this.lockoutEnd.toISOString() : <any>undefined;
        data["lockoutEnabled"] = this.lockoutEnabled;
        data["accessFailedCount"] = this.accessFailedCount;
        return data; 
    }
}

export interface IApplicationUser {
    id?: string | undefined;
    userName?: string | undefined;
    normalizedUserName?: string | undefined;
    email?: string | undefined;
    normalizedEmail?: string | undefined;
    emailConfirmed?: boolean | undefined;
    passwordHash?: string | undefined;
    securityStamp?: string | undefined;
    concurrencyStamp?: string | undefined;
    phoneNumber?: string | undefined;
    phoneNumberConfirmed?: boolean | undefined;
    twoFactorEnabled?: boolean | undefined;
    lockoutEnd?: Date | undefined;
    lockoutEnabled?: boolean | undefined;
    accessFailedCount?: number | undefined;
}

export class ApiResultOfApplicationUser implements IApiResultOfApplicationUser {
    readonly data?: ApplicationUser | undefined;
    readonly success?: boolean | undefined;
    readonly errors?: string[] | undefined;

    constructor(data?: IApiResultOfApplicationUser) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).data = _data["data"] ? ApplicationUser.fromJS(_data["data"]) : <any>undefined;
            (<any>this).success = _data["success"];
            if (Array.isArray(_data["errors"])) {
                (<any>this).errors = [] as any;
                for (let item of _data["errors"])
                    (<any>this).errors!.push(item);
            }
        }
    }

    static fromJS(data: any): ApiResultOfApplicationUser {
        data = typeof data === 'object' ? data : {};
        let result = new ApiResultOfApplicationUser();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["success"] = this.success;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        return data; 
    }
}

export interface IApiResultOfApplicationUser {
    data?: ApplicationUser | undefined;
    success?: boolean | undefined;
    errors?: string[] | undefined;
}

export class ChangePasswordViewModel implements IChangePasswordViewModel {
    oldPassword!: string;
    newPassword!: string;
    confirmPassword?: string | undefined;
    statusMessage?: string | undefined;

    constructor(data?: IChangePasswordViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.oldPassword = _data["oldPassword"];
            this.newPassword = _data["newPassword"];
            this.confirmPassword = _data["confirmPassword"];
            this.statusMessage = _data["statusMessage"];
        }
    }

    static fromJS(data: any): ChangePasswordViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new ChangePasswordViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["oldPassword"] = this.oldPassword;
        data["newPassword"] = this.newPassword;
        data["confirmPassword"] = this.confirmPassword;
        data["statusMessage"] = this.statusMessage;
        return data; 
    }
}

export interface IChangePasswordViewModel {
    oldPassword: string;
    newPassword: string;
    confirmPassword?: string | undefined;
    statusMessage?: string | undefined;
}

export class ApiResultOfChangePasswordViewModel implements IApiResultOfChangePasswordViewModel {
    readonly data?: ChangePasswordViewModel | undefined;
    readonly success?: boolean | undefined;
    readonly errors?: string[] | undefined;

    constructor(data?: IApiResultOfChangePasswordViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).data = _data["data"] ? ChangePasswordViewModel.fromJS(_data["data"]) : <any>undefined;
            (<any>this).success = _data["success"];
            if (Array.isArray(_data["errors"])) {
                (<any>this).errors = [] as any;
                for (let item of _data["errors"])
                    (<any>this).errors!.push(item);
            }
        }
    }

    static fromJS(data: any): ApiResultOfChangePasswordViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new ApiResultOfChangePasswordViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["success"] = this.success;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        return data; 
    }
}

export interface IApiResultOfChangePasswordViewModel {
    data?: ChangePasswordViewModel | undefined;
    success?: boolean | undefined;
    errors?: string[] | undefined;
}

export class ForgotPasswordViewModel implements IForgotPasswordViewModel {
    email!: string;

    constructor(data?: IForgotPasswordViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.email = _data["email"];
        }
    }

    static fromJS(data: any): ForgotPasswordViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new ForgotPasswordViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["email"] = this.email;
        return data; 
    }
}

export interface IForgotPasswordViewModel {
    email: string;
}

export class ApiResultOfForgotPasswordViewModel implements IApiResultOfForgotPasswordViewModel {
    readonly data?: ForgotPasswordViewModel | undefined;
    readonly success?: boolean | undefined;
    readonly errors?: string[] | undefined;

    constructor(data?: IApiResultOfForgotPasswordViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).data = _data["data"] ? ForgotPasswordViewModel.fromJS(_data["data"]) : <any>undefined;
            (<any>this).success = _data["success"];
            if (Array.isArray(_data["errors"])) {
                (<any>this).errors = [] as any;
                for (let item of _data["errors"])
                    (<any>this).errors!.push(item);
            }
        }
    }

    static fromJS(data: any): ApiResultOfForgotPasswordViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new ApiResultOfForgotPasswordViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["success"] = this.success;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        return data; 
    }
}

export interface IApiResultOfForgotPasswordViewModel {
    data?: ForgotPasswordViewModel | undefined;
    success?: boolean | undefined;
    errors?: string[] | undefined;
}

export class ResetPasswordViewModel implements IResetPasswordViewModel {
    email!: string;
    password!: string;
    confirmPassword?: string | undefined;
    code?: string | undefined;

    constructor(data?: IResetPasswordViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.email = _data["email"];
            this.password = _data["password"];
            this.confirmPassword = _data["confirmPassword"];
            this.code = _data["code"];
        }
    }

    static fromJS(data: any): ResetPasswordViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new ResetPasswordViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["email"] = this.email;
        data["password"] = this.password;
        data["confirmPassword"] = this.confirmPassword;
        data["code"] = this.code;
        return data; 
    }
}

export interface IResetPasswordViewModel {
    email: string;
    password: string;
    confirmPassword?: string | undefined;
    code?: string | undefined;
}

export class ApiResultOfResetPasswordViewModel implements IApiResultOfResetPasswordViewModel {
    readonly data?: ResetPasswordViewModel | undefined;
    readonly success?: boolean | undefined;
    readonly errors?: string[] | undefined;

    constructor(data?: IApiResultOfResetPasswordViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).data = _data["data"] ? ResetPasswordViewModel.fromJS(_data["data"]) : <any>undefined;
            (<any>this).success = _data["success"];
            if (Array.isArray(_data["errors"])) {
                (<any>this).errors = [] as any;
                for (let item of _data["errors"])
                    (<any>this).errors!.push(item);
            }
        }
    }

    static fromJS(data: any): ApiResultOfResetPasswordViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new ApiResultOfResetPasswordViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["success"] = this.success;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        return data; 
    }
}

export interface IApiResultOfResetPasswordViewModel {
    data?: ResetPasswordViewModel | undefined;
    success?: boolean | undefined;
    errors?: string[] | undefined;
}

export class ApiResultOfBoolean implements IApiResultOfBoolean {
    readonly data?: boolean | undefined;
    readonly success?: boolean | undefined;
    readonly errors?: string[] | undefined;

    constructor(data?: IApiResultOfBoolean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).data = _data["data"];
            (<any>this).success = _data["success"];
            if (Array.isArray(_data["errors"])) {
                (<any>this).errors = [] as any;
                for (let item of _data["errors"])
                    (<any>this).errors!.push(item);
            }
        }
    }

    static fromJS(data: any): ApiResultOfBoolean {
        data = typeof data === 'object' ? data : {};
        let result = new ApiResultOfBoolean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data"] = this.data;
        data["success"] = this.success;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        return data; 
    }
}

export interface IApiResultOfBoolean {
    data?: boolean | undefined;
    success?: boolean | undefined;
    errors?: string[] | undefined;
}

export class ApiResultOfInt32 implements IApiResultOfInt32 {
    readonly data?: number | undefined;
    readonly success?: boolean | undefined;
    readonly errors?: string[] | undefined;

    constructor(data?: IApiResultOfInt32) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).data = _data["data"];
            (<any>this).success = _data["success"];
            if (Array.isArray(_data["errors"])) {
                (<any>this).errors = [] as any;
                for (let item of _data["errors"])
                    (<any>this).errors!.push(item);
            }
        }
    }

    static fromJS(data: any): ApiResultOfInt32 {
        data = typeof data === 'object' ? data : {};
        let result = new ApiResultOfInt32();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data"] = this.data;
        data["success"] = this.success;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        return data; 
    }
}

export interface IApiResultOfInt32 {
    data?: number | undefined;
    success?: boolean | undefined;
    errors?: string[] | undefined;
}

export class ApiResultOfIEnumerableOfString implements IApiResultOfIEnumerableOfString {
    readonly data?: string[] | undefined;
    readonly success?: boolean | undefined;
    readonly errors?: string[] | undefined;

    constructor(data?: IApiResultOfIEnumerableOfString) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["data"])) {
                (<any>this).data = [] as any;
                for (let item of _data["data"])
                    (<any>this).data!.push(item);
            }
            (<any>this).success = _data["success"];
            if (Array.isArray(_data["errors"])) {
                (<any>this).errors = [] as any;
                for (let item of _data["errors"])
                    (<any>this).errors!.push(item);
            }
        }
    }

    static fromJS(data: any): ApiResultOfIEnumerableOfString {
        data = typeof data === 'object' ? data : {};
        let result = new ApiResultOfIEnumerableOfString();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item);
        }
        data["success"] = this.success;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        return data; 
    }
}

export interface IApiResultOfIEnumerableOfString {
    data?: string[] | undefined;
    success?: boolean | undefined;
    errors?: string[] | undefined;
}

export class ApiResultOfIFormFile implements IApiResultOfIFormFile {
    readonly data?: IFormFile | undefined;
    readonly success?: boolean | undefined;
    readonly errors?: string[] | undefined;

    constructor(data?: IApiResultOfIFormFile) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).data = _data["data"] ? IFormFile.fromJS(_data["data"]) : <any>undefined;
            (<any>this).success = _data["success"];
            if (Array.isArray(_data["errors"])) {
                (<any>this).errors = [] as any;
                for (let item of _data["errors"])
                    (<any>this).errors!.push(item);
            }
        }
    }

    static fromJS(data: any): ApiResultOfIFormFile {
        data = typeof data === 'object' ? data : {};
        let result = new ApiResultOfIFormFile();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["success"] = this.success;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        return data; 
    }
}

export interface IApiResultOfIFormFile {
    data?: IFormFile | undefined;
    success?: boolean | undefined;
    errors?: string[] | undefined;
}

export class IFormFile implements IIFormFile {
    readonly contentType?: string | undefined;
    readonly contentDisposition?: string | undefined;
    readonly headers?: { [key: string]: string[]; } | undefined;
    readonly length?: number | undefined;
    readonly name?: string | undefined;
    readonly fileName?: string | undefined;

    constructor(data?: IIFormFile) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).contentType = _data["contentType"];
            (<any>this).contentDisposition = _data["contentDisposition"];
            if (_data["headers"]) {
                (<any>this).headers = {} as any;
                for (let key in _data["headers"]) {
                    if (_data["headers"].hasOwnProperty(key))
                        (<any>this).headers![key] = _data["headers"][key] !== undefined ? _data["headers"][key] : [];
                }
            }
            (<any>this).length = _data["length"];
            (<any>this).name = _data["name"];
            (<any>this).fileName = _data["fileName"];
        }
    }

    static fromJS(data: any): IFormFile {
        data = typeof data === 'object' ? data : {};
        let result = new IFormFile();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["contentType"] = this.contentType;
        data["contentDisposition"] = this.contentDisposition;
        if (this.headers) {
            data["headers"] = {};
            for (let key in this.headers) {
                if (this.headers.hasOwnProperty(key))
                    data["headers"][key] = this.headers[key];
            }
        }
        data["length"] = this.length;
        data["name"] = this.name;
        data["fileName"] = this.fileName;
        return data; 
    }
}

export interface IIFormFile {
    contentType?: string | undefined;
    contentDisposition?: string | undefined;
    headers?: { [key: string]: string[]; } | undefined;
    length?: number | undefined;
    name?: string | undefined;
    fileName?: string | undefined;
}

export class GameAccountViewModel implements IGameAccountViewModel {
    id?: string | undefined;
    alias!: string;
    account?: string | undefined;

    constructor(data?: IGameAccountViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.alias = _data["alias"];
            this.account = _data["account"];
        }
    }

    static fromJS(data: any): GameAccountViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new GameAccountViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["alias"] = this.alias;
        data["account"] = this.account;
        return data; 
    }
}

export interface IGameAccountViewModel {
    id?: string | undefined;
    alias: string;
    account?: string | undefined;
}

export class ApiResultOfGameAccountViewModel implements IApiResultOfGameAccountViewModel {
    readonly data?: GameAccountViewModel | undefined;
    readonly success?: boolean | undefined;
    readonly errors?: string[] | undefined;

    constructor(data?: IApiResultOfGameAccountViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).data = _data["data"] ? GameAccountViewModel.fromJS(_data["data"]) : <any>undefined;
            (<any>this).success = _data["success"];
            if (Array.isArray(_data["errors"])) {
                (<any>this).errors = [] as any;
                for (let item of _data["errors"])
                    (<any>this).errors!.push(item);
            }
        }
    }

    static fromJS(data: any): ApiResultOfGameAccountViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new ApiResultOfGameAccountViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["success"] = this.success;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        return data; 
    }
}

export interface IApiResultOfGameAccountViewModel {
    data?: GameAccountViewModel | undefined;
    success?: boolean | undefined;
    errors?: string[] | undefined;
}

export class ApiResultOfIPagedListOfGameAccountViewModel implements IApiResultOfIPagedListOfGameAccountViewModel {
    readonly data?: GameAccountViewModel[] | undefined;
    readonly success?: boolean | undefined;
    readonly errors?: string[] | undefined;

    constructor(data?: IApiResultOfIPagedListOfGameAccountViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["data"])) {
                (<any>this).data = [] as any;
                for (let item of _data["data"])
                    (<any>this).data!.push(GameAccountViewModel.fromJS(item));
            }
            (<any>this).success = _data["success"];
            if (Array.isArray(_data["errors"])) {
                (<any>this).errors = [] as any;
                for (let item of _data["errors"])
                    (<any>this).errors!.push(item);
            }
        }
    }

    static fromJS(data: any): ApiResultOfIPagedListOfGameAccountViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new ApiResultOfIPagedListOfGameAccountViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["success"] = this.success;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        return data; 
    }
}

export interface IApiResultOfIPagedListOfGameAccountViewModel {
    data?: GameAccountViewModel[] | undefined;
    success?: boolean | undefined;
    errors?: string[] | undefined;
}

export class ApiResultOfPagedResultDataOfIEnumerableOfCharacterAdminViewModel implements IApiResultOfPagedResultDataOfIEnumerableOfCharacterAdminViewModel {
    readonly data?: PagedResultDataOfIEnumerableOfCharacterAdminViewModel | undefined;
    readonly success?: boolean | undefined;
    readonly errors?: string[] | undefined;

    constructor(data?: IApiResultOfPagedResultDataOfIEnumerableOfCharacterAdminViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).data = _data["data"] ? PagedResultDataOfIEnumerableOfCharacterAdminViewModel.fromJS(_data["data"]) : <any>undefined;
            (<any>this).success = _data["success"];
            if (Array.isArray(_data["errors"])) {
                (<any>this).errors = [] as any;
                for (let item of _data["errors"])
                    (<any>this).errors!.push(item);
            }
        }
    }

    static fromJS(data: any): ApiResultOfPagedResultDataOfIEnumerableOfCharacterAdminViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new ApiResultOfPagedResultDataOfIEnumerableOfCharacterAdminViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["success"] = this.success;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        return data; 
    }
}

export interface IApiResultOfPagedResultDataOfIEnumerableOfCharacterAdminViewModel {
    data?: PagedResultDataOfIEnumerableOfCharacterAdminViewModel | undefined;
    success?: boolean | undefined;
    errors?: string[] | undefined;
}

export class PagedResultDataOfIEnumerableOfCharacterAdminViewModel implements IPagedResultDataOfIEnumerableOfCharacterAdminViewModel {
    readonly content?: CharacterAdminViewModel[] | undefined;
    readonly recordCount?: number | undefined;
    readonly currentIndex?: number | undefined;
    readonly currentCountPerPage?: number | undefined;
    readonly pageCount?: number | undefined;

    constructor(data?: IPagedResultDataOfIEnumerableOfCharacterAdminViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["content"])) {
                (<any>this).content = [] as any;
                for (let item of _data["content"])
                    (<any>this).content!.push(CharacterAdminViewModel.fromJS(item));
            }
            (<any>this).recordCount = _data["recordCount"];
            (<any>this).currentIndex = _data["currentIndex"];
            (<any>this).currentCountPerPage = _data["currentCountPerPage"];
            (<any>this).pageCount = _data["pageCount"];
        }
    }

    static fromJS(data: any): PagedResultDataOfIEnumerableOfCharacterAdminViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDataOfIEnumerableOfCharacterAdminViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.content)) {
            data["content"] = [];
            for (let item of this.content)
                data["content"].push(item.toJSON());
        }
        data["recordCount"] = this.recordCount;
        data["currentIndex"] = this.currentIndex;
        data["currentCountPerPage"] = this.currentCountPerPage;
        data["pageCount"] = this.pageCount;
        return data; 
    }
}

export interface IPagedResultDataOfIEnumerableOfCharacterAdminViewModel {
    content?: CharacterAdminViewModel[] | undefined;
    recordCount?: number | undefined;
    currentIndex?: number | undefined;
    currentCountPerPage?: number | undefined;
    pageCount?: number | undefined;
}

export class CharacterAdminViewModel implements ICharacterAdminViewModel {
    id?: string | undefined;
    updatedOn?: Date | undefined;
    updateId?: string | undefined;
    isStaff?: boolean | undefined;
    playerId?: string | undefined;
    account?: string | undefined;
    name?: string | undefined;
    class?: string | undefined;
    gearScore?: number | undefined;
    level?: number | undefined;
    playTime?: number | undefined;
    createdOn?: Date | undefined;
    strength?: number | undefined;
    dexterity?: number | undefined;
    stamina?: number | undefined;
    intelligence?: number | undefined;
    perin?: number | undefined;
    penya?: number | undefined;
    redChips?: number | undefined;
    euphresiaCoins?: number | undefined;
    votePoints?: number | undefined;
    donateCoins?: number | undefined;
    bossKills?: number | undefined;
    isDeleted?: boolean | undefined;

    constructor(data?: ICharacterAdminViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.updatedOn = _data["updatedOn"] ? new Date(_data["updatedOn"].toString()) : <any>undefined;
            this.updateId = _data["updateId"];
            this.isStaff = _data["isStaff"];
            this.playerId = _data["playerId"];
            this.account = _data["account"];
            this.name = _data["name"];
            this.class = _data["class"];
            this.gearScore = _data["gearScore"];
            this.level = _data["level"];
            this.playTime = _data["playTime"];
            this.createdOn = _data["createdOn"] ? new Date(_data["createdOn"].toString()) : <any>undefined;
            this.strength = _data["strength"];
            this.dexterity = _data["dexterity"];
            this.stamina = _data["stamina"];
            this.intelligence = _data["intelligence"];
            this.perin = _data["perin"];
            this.penya = _data["penya"];
            this.redChips = _data["redChips"];
            this.euphresiaCoins = _data["euphresiaCoins"];
            this.votePoints = _data["votePoints"];
            this.donateCoins = _data["donateCoins"];
            this.bossKills = _data["bossKills"];
            this.isDeleted = _data["isDeleted"];
        }
    }

    static fromJS(data: any): CharacterAdminViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new CharacterAdminViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["updatedOn"] = this.updatedOn ? this.updatedOn.toISOString() : <any>undefined;
        data["updateId"] = this.updateId;
        data["isStaff"] = this.isStaff;
        data["playerId"] = this.playerId;
        data["account"] = this.account;
        data["name"] = this.name;
        data["class"] = this.class;
        data["gearScore"] = this.gearScore;
        data["level"] = this.level;
        data["playTime"] = this.playTime;
        data["createdOn"] = this.createdOn ? this.createdOn.toISOString() : <any>undefined;
        data["strength"] = this.strength;
        data["dexterity"] = this.dexterity;
        data["stamina"] = this.stamina;
        data["intelligence"] = this.intelligence;
        data["perin"] = this.perin;
        data["penya"] = this.penya;
        data["redChips"] = this.redChips;
        data["euphresiaCoins"] = this.euphresiaCoins;
        data["votePoints"] = this.votePoints;
        data["donateCoins"] = this.donateCoins;
        data["bossKills"] = this.bossKills;
        data["isDeleted"] = this.isDeleted;
        return data; 
    }
}

export interface ICharacterAdminViewModel {
    id?: string | undefined;
    updatedOn?: Date | undefined;
    updateId?: string | undefined;
    isStaff?: boolean | undefined;
    playerId?: string | undefined;
    account?: string | undefined;
    name?: string | undefined;
    class?: string | undefined;
    gearScore?: number | undefined;
    level?: number | undefined;
    playTime?: number | undefined;
    createdOn?: Date | undefined;
    strength?: number | undefined;
    dexterity?: number | undefined;
    stamina?: number | undefined;
    intelligence?: number | undefined;
    perin?: number | undefined;
    penya?: number | undefined;
    redChips?: number | undefined;
    euphresiaCoins?: number | undefined;
    votePoints?: number | undefined;
    donateCoins?: number | undefined;
    bossKills?: number | undefined;
    isDeleted?: boolean | undefined;
}

export class ApiResultOfIEnumerableOfCharacterViewModel implements IApiResultOfIEnumerableOfCharacterViewModel {
    readonly data?: CharacterViewModel[] | undefined;
    readonly success?: boolean | undefined;
    readonly errors?: string[] | undefined;

    constructor(data?: IApiResultOfIEnumerableOfCharacterViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["data"])) {
                (<any>this).data = [] as any;
                for (let item of _data["data"])
                    (<any>this).data!.push(CharacterViewModel.fromJS(item));
            }
            (<any>this).success = _data["success"];
            if (Array.isArray(_data["errors"])) {
                (<any>this).errors = [] as any;
                for (let item of _data["errors"])
                    (<any>this).errors!.push(item);
            }
        }
    }

    static fromJS(data: any): ApiResultOfIEnumerableOfCharacterViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new ApiResultOfIEnumerableOfCharacterViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["success"] = this.success;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        return data; 
    }
}

export interface IApiResultOfIEnumerableOfCharacterViewModel {
    data?: CharacterViewModel[] | undefined;
    success?: boolean | undefined;
    errors?: string[] | undefined;
}

export class CharacterViewModel implements ICharacterViewModel {
    name?: string | undefined;
    class?: string | undefined;
    gearScore?: number | undefined;
    level?: number | undefined;
    playTime?: number | undefined;
    strength?: number | undefined;
    dexterity?: number | undefined;
    stamina?: number | undefined;
    intelligence?: number | undefined;
    bossKills?: number | undefined;

    constructor(data?: ICharacterViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.class = _data["class"];
            this.gearScore = _data["gearScore"];
            this.level = _data["level"];
            this.playTime = _data["playTime"];
            this.strength = _data["strength"];
            this.dexterity = _data["dexterity"];
            this.stamina = _data["stamina"];
            this.intelligence = _data["intelligence"];
            this.bossKills = _data["bossKills"];
        }
    }

    static fromJS(data: any): CharacterViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new CharacterViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["class"] = this.class;
        data["gearScore"] = this.gearScore;
        data["level"] = this.level;
        data["playTime"] = this.playTime;
        data["strength"] = this.strength;
        data["dexterity"] = this.dexterity;
        data["stamina"] = this.stamina;
        data["intelligence"] = this.intelligence;
        data["bossKills"] = this.bossKills;
        return data; 
    }
}

export interface ICharacterViewModel {
    name?: string | undefined;
    class?: string | undefined;
    gearScore?: number | undefined;
    level?: number | undefined;
    playTime?: number | undefined;
    strength?: number | undefined;
    dexterity?: number | undefined;
    stamina?: number | undefined;
    intelligence?: number | undefined;
    bossKills?: number | undefined;
}

export class ApiResultOfIListOfStoredEvent implements IApiResultOfIListOfStoredEvent {
    readonly data?: StoredEvent[] | undefined;
    readonly success?: boolean | undefined;
    readonly errors?: string[] | undefined;

    constructor(data?: IApiResultOfIListOfStoredEvent) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["data"])) {
                (<any>this).data = [] as any;
                for (let item of _data["data"])
                    (<any>this).data!.push(StoredEvent.fromJS(item));
            }
            (<any>this).success = _data["success"];
            if (Array.isArray(_data["errors"])) {
                (<any>this).errors = [] as any;
                for (let item of _data["errors"])
                    (<any>this).errors!.push(item);
            }
        }
    }

    static fromJS(data: any): ApiResultOfIListOfStoredEvent {
        data = typeof data === 'object' ? data : {};
        let result = new ApiResultOfIListOfStoredEvent();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["success"] = this.success;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        return data; 
    }
}

export interface IApiResultOfIListOfStoredEvent {
    data?: StoredEvent[] | undefined;
    success?: boolean | undefined;
    errors?: string[] | undefined;
}

export class StoredEvent implements IStoredEvent {
    id?: string | undefined;
    data?: string | undefined;
    user?: string | undefined;
    handled?: boolean | undefined;
    handledTimeStamp?: Date | undefined;
    readonly timestamp?: Date | undefined;
    readonly messageType?: string | undefined;
    readonly aggregateId?: string | undefined;

    constructor(data?: IStoredEvent) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.data = _data["data"];
            this.user = _data["user"];
            this.handled = _data["handled"];
            this.handledTimeStamp = _data["handledTimeStamp"] ? new Date(_data["handledTimeStamp"].toString()) : <any>undefined;
            (<any>this).timestamp = _data["timestamp"] ? new Date(_data["timestamp"].toString()) : <any>undefined;
            (<any>this).messageType = _data["messageType"];
            (<any>this).aggregateId = _data["aggregateId"];
        }
    }

    static fromJS(data: any): StoredEvent {
        data = typeof data === 'object' ? data : {};
        let result = new StoredEvent();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["data"] = this.data;
        data["user"] = this.user;
        data["handled"] = this.handled;
        data["handledTimeStamp"] = this.handledTimeStamp ? this.handledTimeStamp.toISOString() : <any>undefined;
        data["timestamp"] = this.timestamp ? this.timestamp.toISOString() : <any>undefined;
        data["messageType"] = this.messageType;
        data["aggregateId"] = this.aggregateId;
        return data; 
    }
}

export interface IStoredEvent {
    id?: string | undefined;
    data?: string | undefined;
    user?: string | undefined;
    handled?: boolean | undefined;
    handledTimeStamp?: Date | undefined;
    timestamp?: Date | undefined;
    messageType?: string | undefined;
    aggregateId?: string | undefined;
}

export class ApiResultOfGuid implements IApiResultOfGuid {
    readonly data?: string | undefined;
    readonly success?: boolean | undefined;
    readonly errors?: string[] | undefined;

    constructor(data?: IApiResultOfGuid) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).data = _data["data"];
            (<any>this).success = _data["success"];
            if (Array.isArray(_data["errors"])) {
                (<any>this).errors = [] as any;
                for (let item of _data["errors"])
                    (<any>this).errors!.push(item);
            }
        }
    }

    static fromJS(data: any): ApiResultOfGuid {
        data = typeof data === 'object' ? data : {};
        let result = new ApiResultOfGuid();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data"] = this.data;
        data["success"] = this.success;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        return data; 
    }
}

export interface IApiResultOfGuid {
    data?: string | undefined;
    success?: boolean | undefined;
    errors?: string[] | undefined;
}

export class ApiResultOfIEnumerableOfGenericObjectViewModel implements IApiResultOfIEnumerableOfGenericObjectViewModel {
    readonly data?: GenericObjectViewModel[] | undefined;
    readonly success?: boolean | undefined;
    readonly errors?: string[] | undefined;

    constructor(data?: IApiResultOfIEnumerableOfGenericObjectViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["data"])) {
                (<any>this).data = [] as any;
                for (let item of _data["data"])
                    (<any>this).data!.push(GenericObjectViewModel.fromJS(item));
            }
            (<any>this).success = _data["success"];
            if (Array.isArray(_data["errors"])) {
                (<any>this).errors = [] as any;
                for (let item of _data["errors"])
                    (<any>this).errors!.push(item);
            }
        }
    }

    static fromJS(data: any): ApiResultOfIEnumerableOfGenericObjectViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new ApiResultOfIEnumerableOfGenericObjectViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["success"] = this.success;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        return data; 
    }
}

export interface IApiResultOfIEnumerableOfGenericObjectViewModel {
    data?: GenericObjectViewModel[] | undefined;
    success?: boolean | undefined;
    errors?: string[] | undefined;
}

export class GenericObjectViewModel implements IGenericObjectViewModel {
    id?: string | undefined;
    createdOn?: Date | undefined;
    type!: string;
    valueType?: string | undefined;
    value!: string;

    constructor(data?: IGenericObjectViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.createdOn = _data["createdOn"] ? new Date(_data["createdOn"].toString()) : <any>undefined;
            this.type = _data["type"];
            this.valueType = _data["valueType"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): GenericObjectViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new GenericObjectViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["createdOn"] = this.createdOn ? this.createdOn.toISOString() : <any>undefined;
        data["type"] = this.type;
        data["valueType"] = this.valueType;
        data["value"] = this.value;
        return data; 
    }
}

export interface IGenericObjectViewModel {
    id?: string | undefined;
    createdOn?: Date | undefined;
    type: string;
    valueType?: string | undefined;
    value: string;
}

export class ApiResultOfGenericObjectViewModel implements IApiResultOfGenericObjectViewModel {
    readonly data?: GenericObjectViewModel | undefined;
    readonly success?: boolean | undefined;
    readonly errors?: string[] | undefined;

    constructor(data?: IApiResultOfGenericObjectViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).data = _data["data"] ? GenericObjectViewModel.fromJS(_data["data"]) : <any>undefined;
            (<any>this).success = _data["success"];
            if (Array.isArray(_data["errors"])) {
                (<any>this).errors = [] as any;
                for (let item of _data["errors"])
                    (<any>this).errors!.push(item);
            }
        }
    }

    static fromJS(data: any): ApiResultOfGenericObjectViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new ApiResultOfGenericObjectViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["success"] = this.success;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        return data; 
    }
}

export interface IApiResultOfGenericObjectViewModel {
    data?: GenericObjectViewModel | undefined;
    success?: boolean | undefined;
    errors?: string[] | undefined;
}

export class ApiResultOfPagedResultDataOfIEnumerableOfNewsPostViewModel implements IApiResultOfPagedResultDataOfIEnumerableOfNewsPostViewModel {
    readonly data?: PagedResultDataOfIEnumerableOfNewsPostViewModel | undefined;
    readonly success?: boolean | undefined;
    readonly errors?: string[] | undefined;

    constructor(data?: IApiResultOfPagedResultDataOfIEnumerableOfNewsPostViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).data = _data["data"] ? PagedResultDataOfIEnumerableOfNewsPostViewModel.fromJS(_data["data"]) : <any>undefined;
            (<any>this).success = _data["success"];
            if (Array.isArray(_data["errors"])) {
                (<any>this).errors = [] as any;
                for (let item of _data["errors"])
                    (<any>this).errors!.push(item);
            }
        }
    }

    static fromJS(data: any): ApiResultOfPagedResultDataOfIEnumerableOfNewsPostViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new ApiResultOfPagedResultDataOfIEnumerableOfNewsPostViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["success"] = this.success;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        return data; 
    }
}

export interface IApiResultOfPagedResultDataOfIEnumerableOfNewsPostViewModel {
    data?: PagedResultDataOfIEnumerableOfNewsPostViewModel | undefined;
    success?: boolean | undefined;
    errors?: string[] | undefined;
}

export class PagedResultDataOfIEnumerableOfNewsPostViewModel implements IPagedResultDataOfIEnumerableOfNewsPostViewModel {
    readonly content?: NewsPostViewModel[] | undefined;
    readonly recordCount?: number | undefined;
    readonly currentIndex?: number | undefined;
    readonly currentCountPerPage?: number | undefined;
    readonly pageCount?: number | undefined;

    constructor(data?: IPagedResultDataOfIEnumerableOfNewsPostViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["content"])) {
                (<any>this).content = [] as any;
                for (let item of _data["content"])
                    (<any>this).content!.push(NewsPostViewModel.fromJS(item));
            }
            (<any>this).recordCount = _data["recordCount"];
            (<any>this).currentIndex = _data["currentIndex"];
            (<any>this).currentCountPerPage = _data["currentCountPerPage"];
            (<any>this).pageCount = _data["pageCount"];
        }
    }

    static fromJS(data: any): PagedResultDataOfIEnumerableOfNewsPostViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDataOfIEnumerableOfNewsPostViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.content)) {
            data["content"] = [];
            for (let item of this.content)
                data["content"].push(item.toJSON());
        }
        data["recordCount"] = this.recordCount;
        data["currentIndex"] = this.currentIndex;
        data["currentCountPerPage"] = this.currentCountPerPage;
        data["pageCount"] = this.pageCount;
        return data; 
    }
}

export interface IPagedResultDataOfIEnumerableOfNewsPostViewModel {
    content?: NewsPostViewModel[] | undefined;
    recordCount?: number | undefined;
    currentIndex?: number | undefined;
    currentCountPerPage?: number | undefined;
    pageCount?: number | undefined;
}

export class NewsPostViewModel implements INewsPostViewModel {
    id?: string | undefined;
    caption!: string;
    content?: string | undefined;
    imageUrlSmallTile?: string | undefined;
    imageUrlBigTile?: string | undefined;
    imageUrlBanner?: string | undefined;
    forumPostUrl?: string | undefined;
    tags?: string | undefined;
    public?: boolean | undefined;
    createdOn?: Date | undefined;

    constructor(data?: INewsPostViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.caption = _data["caption"];
            this.content = _data["content"];
            this.imageUrlSmallTile = _data["imageUrlSmallTile"];
            this.imageUrlBigTile = _data["imageUrlBigTile"];
            this.imageUrlBanner = _data["imageUrlBanner"];
            this.forumPostUrl = _data["forumPostUrl"];
            this.tags = _data["tags"];
            this.public = _data["public"];
            this.createdOn = _data["createdOn"] ? new Date(_data["createdOn"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): NewsPostViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new NewsPostViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["caption"] = this.caption;
        data["content"] = this.content;
        data["imageUrlSmallTile"] = this.imageUrlSmallTile;
        data["imageUrlBigTile"] = this.imageUrlBigTile;
        data["imageUrlBanner"] = this.imageUrlBanner;
        data["forumPostUrl"] = this.forumPostUrl;
        data["tags"] = this.tags;
        data["public"] = this.public;
        data["createdOn"] = this.createdOn ? this.createdOn.toISOString() : <any>undefined;
        return data; 
    }
}

export interface INewsPostViewModel {
    id?: string | undefined;
    caption: string;
    content?: string | undefined;
    imageUrlSmallTile?: string | undefined;
    imageUrlBigTile?: string | undefined;
    imageUrlBanner?: string | undefined;
    forumPostUrl?: string | undefined;
    tags?: string | undefined;
    public?: boolean | undefined;
    createdOn?: Date | undefined;
}

export class ApiResultOfNewsPostViewModel implements IApiResultOfNewsPostViewModel {
    readonly data?: NewsPostViewModel | undefined;
    readonly success?: boolean | undefined;
    readonly errors?: string[] | undefined;

    constructor(data?: IApiResultOfNewsPostViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).data = _data["data"] ? NewsPostViewModel.fromJS(_data["data"]) : <any>undefined;
            (<any>this).success = _data["success"];
            if (Array.isArray(_data["errors"])) {
                (<any>this).errors = [] as any;
                for (let item of _data["errors"])
                    (<any>this).errors!.push(item);
            }
        }
    }

    static fromJS(data: any): ApiResultOfNewsPostViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new ApiResultOfNewsPostViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["success"] = this.success;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        return data; 
    }
}

export interface IApiResultOfNewsPostViewModel {
    data?: NewsPostViewModel | undefined;
    success?: boolean | undefined;
    errors?: string[] | undefined;
}

export class ApiResultOfPagedResultDataOfIEnumerableOfCharacterViewModel implements IApiResultOfPagedResultDataOfIEnumerableOfCharacterViewModel {
    readonly data?: PagedResultDataOfIEnumerableOfCharacterViewModel | undefined;
    readonly success?: boolean | undefined;
    readonly errors?: string[] | undefined;

    constructor(data?: IApiResultOfPagedResultDataOfIEnumerableOfCharacterViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).data = _data["data"] ? PagedResultDataOfIEnumerableOfCharacterViewModel.fromJS(_data["data"]) : <any>undefined;
            (<any>this).success = _data["success"];
            if (Array.isArray(_data["errors"])) {
                (<any>this).errors = [] as any;
                for (let item of _data["errors"])
                    (<any>this).errors!.push(item);
            }
        }
    }

    static fromJS(data: any): ApiResultOfPagedResultDataOfIEnumerableOfCharacterViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new ApiResultOfPagedResultDataOfIEnumerableOfCharacterViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["success"] = this.success;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        return data; 
    }
}

export interface IApiResultOfPagedResultDataOfIEnumerableOfCharacterViewModel {
    data?: PagedResultDataOfIEnumerableOfCharacterViewModel | undefined;
    success?: boolean | undefined;
    errors?: string[] | undefined;
}

export class PagedResultDataOfIEnumerableOfCharacterViewModel implements IPagedResultDataOfIEnumerableOfCharacterViewModel {
    readonly content?: CharacterViewModel[] | undefined;
    readonly recordCount?: number | undefined;
    readonly currentIndex?: number | undefined;
    readonly currentCountPerPage?: number | undefined;
    readonly pageCount?: number | undefined;

    constructor(data?: IPagedResultDataOfIEnumerableOfCharacterViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["content"])) {
                (<any>this).content = [] as any;
                for (let item of _data["content"])
                    (<any>this).content!.push(CharacterViewModel.fromJS(item));
            }
            (<any>this).recordCount = _data["recordCount"];
            (<any>this).currentIndex = _data["currentIndex"];
            (<any>this).currentCountPerPage = _data["currentCountPerPage"];
            (<any>this).pageCount = _data["pageCount"];
        }
    }

    static fromJS(data: any): PagedResultDataOfIEnumerableOfCharacterViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDataOfIEnumerableOfCharacterViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.content)) {
            data["content"] = [];
            for (let item of this.content)
                data["content"].push(item.toJSON());
        }
        data["recordCount"] = this.recordCount;
        data["currentIndex"] = this.currentIndex;
        data["currentCountPerPage"] = this.currentCountPerPage;
        data["pageCount"] = this.pageCount;
        return data; 
    }
}

export interface IPagedResultDataOfIEnumerableOfCharacterViewModel {
    content?: CharacterViewModel[] | undefined;
    recordCount?: number | undefined;
    currentIndex?: number | undefined;
    currentCountPerPage?: number | undefined;
    pageCount?: number | undefined;
}

export class ApiResultOfStringOf implements IApiResultOfStringOf {
    readonly data?: string[] | undefined;
    readonly success?: boolean | undefined;
    readonly errors?: string[] | undefined;

    constructor(data?: IApiResultOfStringOf) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["data"])) {
                (<any>this).data = [] as any;
                for (let item of _data["data"])
                    (<any>this).data!.push(item);
            }
            (<any>this).success = _data["success"];
            if (Array.isArray(_data["errors"])) {
                (<any>this).errors = [] as any;
                for (let item of _data["errors"])
                    (<any>this).errors!.push(item);
            }
        }
    }

    static fromJS(data: any): ApiResultOfStringOf {
        data = typeof data === 'object' ? data : {};
        let result = new ApiResultOfStringOf();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item);
        }
        data["success"] = this.success;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        return data; 
    }
}

export interface IApiResultOfStringOf {
    data?: string[] | undefined;
    success?: boolean | undefined;
    errors?: string[] | undefined;
}

export class UpdateRolesViewModel implements IUpdateRolesViewModel {
    userId?: string | undefined;
    roles?: string[] | undefined;

    constructor(data?: IUpdateRolesViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
            if (Array.isArray(_data["roles"])) {
                this.roles = [] as any;
                for (let item of _data["roles"])
                    this.roles!.push(item);
            }
        }
    }

    static fromJS(data: any): UpdateRolesViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateRolesViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        if (Array.isArray(this.roles)) {
            data["roles"] = [];
            for (let item of this.roles)
                data["roles"].push(item);
        }
        return data; 
    }
}

export interface IUpdateRolesViewModel {
    userId?: string | undefined;
    roles?: string[] | undefined;
}

export class ApiResultOfUpdateRolesViewModel implements IApiResultOfUpdateRolesViewModel {
    readonly data?: UpdateRolesViewModel | undefined;
    readonly success?: boolean | undefined;
    readonly errors?: string[] | undefined;

    constructor(data?: IApiResultOfUpdateRolesViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).data = _data["data"] ? UpdateRolesViewModel.fromJS(_data["data"]) : <any>undefined;
            (<any>this).success = _data["success"];
            if (Array.isArray(_data["errors"])) {
                (<any>this).errors = [] as any;
                for (let item of _data["errors"])
                    (<any>this).errors!.push(item);
            }
        }
    }

    static fromJS(data: any): ApiResultOfUpdateRolesViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new ApiResultOfUpdateRolesViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["success"] = this.success;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        return data; 
    }
}

export interface IApiResultOfUpdateRolesViewModel {
    data?: UpdateRolesViewModel | undefined;
    success?: boolean | undefined;
    errors?: string[] | undefined;
}

export class ApiResultOfIEnumerableOfServiceStatusViewModel implements IApiResultOfIEnumerableOfServiceStatusViewModel {
    readonly data?: ServiceStatusViewModel[] | undefined;
    readonly success?: boolean | undefined;
    readonly errors?: string[] | undefined;

    constructor(data?: IApiResultOfIEnumerableOfServiceStatusViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["data"])) {
                (<any>this).data = [] as any;
                for (let item of _data["data"])
                    (<any>this).data!.push(ServiceStatusViewModel.fromJS(item));
            }
            (<any>this).success = _data["success"];
            if (Array.isArray(_data["errors"])) {
                (<any>this).errors = [] as any;
                for (let item of _data["errors"])
                    (<any>this).errors!.push(item);
            }
        }
    }

    static fromJS(data: any): ApiResultOfIEnumerableOfServiceStatusViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new ApiResultOfIEnumerableOfServiceStatusViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["success"] = this.success;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        return data; 
    }
}

export interface IApiResultOfIEnumerableOfServiceStatusViewModel {
    data?: ServiceStatusViewModel[] | undefined;
    success?: boolean | undefined;
    errors?: string[] | undefined;
}

export class ServiceStatusViewModel implements IServiceStatusViewModel {
    id?: string | undefined;
    service!: string;
    timeStamp?: Date | undefined;
    state?: number | undefined;

    constructor(data?: IServiceStatusViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.service = _data["service"];
            this.timeStamp = _data["timeStamp"] ? new Date(_data["timeStamp"].toString()) : <any>undefined;
            this.state = _data["state"];
        }
    }

    static fromJS(data: any): ServiceStatusViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new ServiceStatusViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["service"] = this.service;
        data["timeStamp"] = this.timeStamp ? this.timeStamp.toISOString() : <any>undefined;
        data["state"] = this.state;
        return data; 
    }
}

export interface IServiceStatusViewModel {
    id?: string | undefined;
    service: string;
    timeStamp?: Date | undefined;
    state?: number | undefined;
}

export class ApiResultOfServiceStatusViewModel implements IApiResultOfServiceStatusViewModel {
    readonly data?: ServiceStatusViewModel | undefined;
    readonly success?: boolean | undefined;
    readonly errors?: string[] | undefined;

    constructor(data?: IApiResultOfServiceStatusViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).data = _data["data"] ? ServiceStatusViewModel.fromJS(_data["data"]) : <any>undefined;
            (<any>this).success = _data["success"];
            if (Array.isArray(_data["errors"])) {
                (<any>this).errors = [] as any;
                for (let item of _data["errors"])
                    (<any>this).errors!.push(item);
            }
        }
    }

    static fromJS(data: any): ApiResultOfServiceStatusViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new ApiResultOfServiceStatusViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["success"] = this.success;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        return data; 
    }
}

export interface IApiResultOfServiceStatusViewModel {
    data?: ServiceStatusViewModel | undefined;
    success?: boolean | undefined;
    errors?: string[] | undefined;
}

export class ApiResultOfIEnumerableOfStatisticsEntryViewModel implements IApiResultOfIEnumerableOfStatisticsEntryViewModel {
    readonly data?: StatisticsEntryViewModel[] | undefined;
    readonly success?: boolean | undefined;
    readonly errors?: string[] | undefined;

    constructor(data?: IApiResultOfIEnumerableOfStatisticsEntryViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["data"])) {
                (<any>this).data = [] as any;
                for (let item of _data["data"])
                    (<any>this).data!.push(StatisticsEntryViewModel.fromJS(item));
            }
            (<any>this).success = _data["success"];
            if (Array.isArray(_data["errors"])) {
                (<any>this).errors = [] as any;
                for (let item of _data["errors"])
                    (<any>this).errors!.push(item);
            }
        }
    }

    static fromJS(data: any): ApiResultOfIEnumerableOfStatisticsEntryViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new ApiResultOfIEnumerableOfStatisticsEntryViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["success"] = this.success;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        return data; 
    }
}

export interface IApiResultOfIEnumerableOfStatisticsEntryViewModel {
    data?: StatisticsEntryViewModel[] | undefined;
    success?: boolean | undefined;
    errors?: string[] | undefined;
}

export class StatisticsEntryViewModel implements IStatisticsEntryViewModel {
    id?: string | undefined;
    start?: Date | undefined;
    end?: Date | undefined;
    statGroup?: string | undefined;
    statName?: string | undefined;
    valueType?: string | undefined;
    value?: string | undefined;

    constructor(data?: IStatisticsEntryViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.start = _data["start"] ? new Date(_data["start"].toString()) : <any>undefined;
            this.end = _data["end"] ? new Date(_data["end"].toString()) : <any>undefined;
            this.statGroup = _data["statGroup"];
            this.statName = _data["statName"];
            this.valueType = _data["valueType"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): StatisticsEntryViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new StatisticsEntryViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["start"] = this.start ? this.start.toISOString() : <any>undefined;
        data["end"] = this.end ? this.end.toISOString() : <any>undefined;
        data["statGroup"] = this.statGroup;
        data["statName"] = this.statName;
        data["valueType"] = this.valueType;
        data["value"] = this.value;
        return data; 
    }
}

export interface IStatisticsEntryViewModel {
    id?: string | undefined;
    start?: Date | undefined;
    end?: Date | undefined;
    statGroup?: string | undefined;
    statName?: string | undefined;
    valueType?: string | undefined;
    value?: string | undefined;
}

export class ApiResultOfIEnumerableOfTransactionViewModel implements IApiResultOfIEnumerableOfTransactionViewModel {
    readonly data?: TransactionViewModel[] | undefined;
    readonly success?: boolean | undefined;
    readonly errors?: string[] | undefined;

    constructor(data?: IApiResultOfIEnumerableOfTransactionViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["data"])) {
                (<any>this).data = [] as any;
                for (let item of _data["data"])
                    (<any>this).data!.push(TransactionViewModel.fromJS(item));
            }
            (<any>this).success = _data["success"];
            if (Array.isArray(_data["errors"])) {
                (<any>this).errors = [] as any;
                for (let item of _data["errors"])
                    (<any>this).errors!.push(item);
            }
        }
    }

    static fromJS(data: any): ApiResultOfIEnumerableOfTransactionViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new ApiResultOfIEnumerableOfTransactionViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["success"] = this.success;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        return data; 
    }
}

export interface IApiResultOfIEnumerableOfTransactionViewModel {
    data?: TransactionViewModel[] | undefined;
    success?: boolean | undefined;
    errors?: string[] | undefined;
}

export class TransactionViewModel implements ITransactionViewModel {
    id?: string | undefined;
    amount?: number | undefined;
    date?: Date | undefined;
    reason?: string | undefined;
    currency?: string | undefined;
    target?: string | undefined;
    targetInfo?: string | undefined;
    status?: string | undefined;

    constructor(data?: ITransactionViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.amount = _data["amount"];
            this.date = _data["date"] ? new Date(_data["date"].toString()) : <any>undefined;
            this.reason = _data["reason"];
            this.currency = _data["currency"];
            this.target = _data["target"];
            this.targetInfo = _data["targetInfo"];
            this.status = _data["status"];
        }
    }

    static fromJS(data: any): TransactionViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new TransactionViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["amount"] = this.amount;
        data["date"] = this.date ? this.date.toISOString() : <any>undefined;
        data["reason"] = this.reason;
        data["currency"] = this.currency;
        data["target"] = this.target;
        data["targetInfo"] = this.targetInfo;
        data["status"] = this.status;
        return data; 
    }
}

export interface ITransactionViewModel {
    id?: string | undefined;
    amount?: number | undefined;
    date?: Date | undefined;
    reason?: string | undefined;
    currency?: string | undefined;
    target?: string | undefined;
    targetInfo?: string | undefined;
    status?: string | undefined;
}

export class ApiResultOfTransactionViewModel implements IApiResultOfTransactionViewModel {
    readonly data?: TransactionViewModel | undefined;
    readonly success?: boolean | undefined;
    readonly errors?: string[] | undefined;

    constructor(data?: IApiResultOfTransactionViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).data = _data["data"] ? TransactionViewModel.fromJS(_data["data"]) : <any>undefined;
            (<any>this).success = _data["success"];
            if (Array.isArray(_data["errors"])) {
                (<any>this).errors = [] as any;
                for (let item of _data["errors"])
                    (<any>this).errors!.push(item);
            }
        }
    }

    static fromJS(data: any): ApiResultOfTransactionViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new ApiResultOfTransactionViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["success"] = this.success;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        return data; 
    }
}

export interface IApiResultOfTransactionViewModel {
    data?: TransactionViewModel | undefined;
    success?: boolean | undefined;
    errors?: string[] | undefined;
}

export class WithdrawCurrencyViewModel implements IWithdrawCurrencyViewModel {
    character!: string;
    currency!: string;
    amount?: number | undefined;

    constructor(data?: IWithdrawCurrencyViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.character = _data["character"];
            this.currency = _data["currency"];
            this.amount = _data["amount"];
        }
    }

    static fromJS(data: any): WithdrawCurrencyViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new WithdrawCurrencyViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["character"] = this.character;
        data["currency"] = this.currency;
        data["amount"] = this.amount;
        return data; 
    }
}

export interface IWithdrawCurrencyViewModel {
    character: string;
    currency: string;
    amount?: number | undefined;
}

export class ApiResultOfWithdrawCurrencyViewModel implements IApiResultOfWithdrawCurrencyViewModel {
    readonly data?: WithdrawCurrencyViewModel | undefined;
    readonly success?: boolean | undefined;
    readonly errors?: string[] | undefined;

    constructor(data?: IApiResultOfWithdrawCurrencyViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).data = _data["data"] ? WithdrawCurrencyViewModel.fromJS(_data["data"]) : <any>undefined;
            (<any>this).success = _data["success"];
            if (Array.isArray(_data["errors"])) {
                (<any>this).errors = [] as any;
                for (let item of _data["errors"])
                    (<any>this).errors!.push(item);
            }
        }
    }

    static fromJS(data: any): ApiResultOfWithdrawCurrencyViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new ApiResultOfWithdrawCurrencyViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["success"] = this.success;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        return data; 
    }
}

export interface IApiResultOfWithdrawCurrencyViewModel {
    data?: WithdrawCurrencyViewModel | undefined;
    success?: boolean | undefined;
    errors?: string[] | undefined;
}

export class ApiResultOfPagedResultDataOfIEnumerableOfTransactionViewModel implements IApiResultOfPagedResultDataOfIEnumerableOfTransactionViewModel {
    readonly data?: PagedResultDataOfIEnumerableOfTransactionViewModel | undefined;
    readonly success?: boolean | undefined;
    readonly errors?: string[] | undefined;

    constructor(data?: IApiResultOfPagedResultDataOfIEnumerableOfTransactionViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).data = _data["data"] ? PagedResultDataOfIEnumerableOfTransactionViewModel.fromJS(_data["data"]) : <any>undefined;
            (<any>this).success = _data["success"];
            if (Array.isArray(_data["errors"])) {
                (<any>this).errors = [] as any;
                for (let item of _data["errors"])
                    (<any>this).errors!.push(item);
            }
        }
    }

    static fromJS(data: any): ApiResultOfPagedResultDataOfIEnumerableOfTransactionViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new ApiResultOfPagedResultDataOfIEnumerableOfTransactionViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["success"] = this.success;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        return data; 
    }
}

export interface IApiResultOfPagedResultDataOfIEnumerableOfTransactionViewModel {
    data?: PagedResultDataOfIEnumerableOfTransactionViewModel | undefined;
    success?: boolean | undefined;
    errors?: string[] | undefined;
}

export class PagedResultDataOfIEnumerableOfTransactionViewModel implements IPagedResultDataOfIEnumerableOfTransactionViewModel {
    readonly content?: TransactionViewModel[] | undefined;
    readonly recordCount?: number | undefined;
    readonly currentIndex?: number | undefined;
    readonly currentCountPerPage?: number | undefined;
    readonly pageCount?: number | undefined;

    constructor(data?: IPagedResultDataOfIEnumerableOfTransactionViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["content"])) {
                (<any>this).content = [] as any;
                for (let item of _data["content"])
                    (<any>this).content!.push(TransactionViewModel.fromJS(item));
            }
            (<any>this).recordCount = _data["recordCount"];
            (<any>this).currentIndex = _data["currentIndex"];
            (<any>this).currentCountPerPage = _data["currentCountPerPage"];
            (<any>this).pageCount = _data["pageCount"];
        }
    }

    static fromJS(data: any): PagedResultDataOfIEnumerableOfTransactionViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDataOfIEnumerableOfTransactionViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.content)) {
            data["content"] = [];
            for (let item of this.content)
                data["content"].push(item.toJSON());
        }
        data["recordCount"] = this.recordCount;
        data["currentIndex"] = this.currentIndex;
        data["currentCountPerPage"] = this.currentCountPerPage;
        data["pageCount"] = this.pageCount;
        return data; 
    }
}

export interface IPagedResultDataOfIEnumerableOfTransactionViewModel {
    content?: TransactionViewModel[] | undefined;
    recordCount?: number | undefined;
    currentIndex?: number | undefined;
    currentCountPerPage?: number | undefined;
    pageCount?: number | undefined;
}

export class ApiResultOfVoteState implements IApiResultOfVoteState {
    readonly data?: VoteState | undefined;
    readonly success?: boolean | undefined;
    readonly errors?: string[] | undefined;

    constructor(data?: IApiResultOfVoteState) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).data = _data["data"] ? VoteState.fromJS(_data["data"]) : <any>undefined;
            (<any>this).success = _data["success"];
            if (Array.isArray(_data["errors"])) {
                (<any>this).errors = [] as any;
                for (let item of _data["errors"])
                    (<any>this).errors!.push(item);
            }
        }
    }

    static fromJS(data: any): ApiResultOfVoteState {
        data = typeof data === 'object' ? data : {};
        let result = new ApiResultOfVoteState();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["success"] = this.success;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        return data; 
    }
}

export interface IApiResultOfVoteState {
    data?: VoteState | undefined;
    success?: boolean | undefined;
    errors?: string[] | undefined;
}

export class VoteState implements IVoteState {
    state?: string | undefined;
    timeSpan?: string | undefined;

    constructor(data?: IVoteState) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.state = _data["state"];
            this.timeSpan = _data["timeSpan"];
        }
    }

    static fromJS(data: any): VoteState {
        data = typeof data === 'object' ? data : {};
        let result = new VoteState();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["state"] = this.state;
        data["timeSpan"] = this.timeSpan;
        return data; 
    }
}

export interface IVoteState {
    state?: string | undefined;
    timeSpan?: string | undefined;
}

export class ApiException extends Error {
    message: string;
    status: number; 
    response: string; 
    headers: { [key: string]: any; };
    result: any; 

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    if (result !== null && result !== undefined)
        return _observableThrow(result);
    else
        return _observableThrow(new ApiException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            let reader = new FileReader(); 
            reader.onload = event => { 
                observer.next((<any>event.target).result);
                observer.complete();
            };
            reader.readAsText(blob); 
        }
    });
}