/* tslint:disable */
/* eslint-disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v12.1.0.0 (NJsonSchema v9.13.30.0 (Newtonsoft.Json v11.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------
// ReSharper disable InconsistentNaming

import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import { Observable, throwError as _observableThrow, of as _observableOf } from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';

export const API_BASE_URL = new InjectionToken<string>('API_BASE_URL');

@Injectable({
    providedIn: 'root'
})
export class AccountService {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param loginViewModel (optional) 
     * @return Success
     */
    login(loginViewModel?: LoginViewModel | null | undefined): Observable<ApiResultOfString> {
        let url_ = this.baseUrl + "/api/v1/account/login";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(loginViewModel);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processLogin(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLogin(<any>response_);
                } catch (e) {
                    return <Observable<ApiResultOfString>><any>_observableThrow(e);
                }
            } else
                return <Observable<ApiResultOfString>><any>_observableThrow(response_);
        }));
    }

    protected processLogin(response: HttpResponseBase): Observable<ApiResultOfString> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ApiResultOfString.fromJS(resultData200) : new ApiResultOfString();
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = resultData400 ? ApiResultOfLoginViewModel.fromJS(resultData400) : new ApiResultOfLoginViewModel();
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApiResultOfString>(<any>null);
    }

    /**
     * @param registerViewModel (optional) 
     * @return Success
     */
    register(registerViewModel?: RegisterViewModel | null | undefined): Observable<ApiResultOfRegisterViewModel> {
        let url_ = this.baseUrl + "/api/v1/account/register";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(registerViewModel);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRegister(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRegister(<any>response_);
                } catch (e) {
                    return <Observable<ApiResultOfRegisterViewModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<ApiResultOfRegisterViewModel>><any>_observableThrow(response_);
        }));
    }

    protected processRegister(response: HttpResponseBase): Observable<ApiResultOfRegisterViewModel> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ApiResultOfRegisterViewModel.fromJS(resultData200) : new ApiResultOfRegisterViewModel();
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = resultData400 ? ApiResultOfRegisterViewModel.fromJS(resultData400) : new ApiResultOfRegisterViewModel();
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApiResultOfRegisterViewModel>(<any>null);
    }

    /**
     * @param index (optional) 
     * @param count (optional) 
     * @param searchText (optional) 
     * @return Success
     */
    account(index?: number | null | undefined, count?: number | null | undefined, searchText?: string | null | undefined): Observable<ApiResultOfPagedResultDataOfIEnumerableOfApplicationUser> {
        let url_ = this.baseUrl + "/api/v1/account?";
        if (index !== undefined)
            url_ += "index=" + encodeURIComponent("" + index) + "&"; 
        if (count !== undefined)
            url_ += "count=" + encodeURIComponent("" + count) + "&"; 
        if (searchText !== undefined)
            url_ += "searchText=" + encodeURIComponent("" + searchText) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAccount(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAccount(<any>response_);
                } catch (e) {
                    return <Observable<ApiResultOfPagedResultDataOfIEnumerableOfApplicationUser>><any>_observableThrow(e);
                }
            } else
                return <Observable<ApiResultOfPagedResultDataOfIEnumerableOfApplicationUser>><any>_observableThrow(response_);
        }));
    }

    protected processAccount(response: HttpResponseBase): Observable<ApiResultOfPagedResultDataOfIEnumerableOfApplicationUser> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ApiResultOfPagedResultDataOfIEnumerableOfApplicationUser.fromJS(resultData200) : new ApiResultOfPagedResultDataOfIEnumerableOfApplicationUser();
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = resultData400 ? ApiResultOfPagedResultDataOfIEnumerableOfApplicationUser.fromJS(resultData400) : new ApiResultOfPagedResultDataOfIEnumerableOfApplicationUser();
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApiResultOfPagedResultDataOfIEnumerableOfApplicationUser>(<any>null);
    }

    /**
     * @return Success
     */
    accountGetByid(id: string): Observable<ApiResultOfApplicationUser> {
        let url_ = this.baseUrl + "/api/v1/account/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAccountGetByid(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAccountGetByid(<any>response_);
                } catch (e) {
                    return <Observable<ApiResultOfApplicationUser>><any>_observableThrow(e);
                }
            } else
                return <Observable<ApiResultOfApplicationUser>><any>_observableThrow(response_);
        }));
    }

    protected processAccountGetByid(response: HttpResponseBase): Observable<ApiResultOfApplicationUser> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ApiResultOfApplicationUser.fromJS(resultData200) : new ApiResultOfApplicationUser();
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = resultData400 ? ApiResultOfApplicationUser.fromJS(resultData400) : new ApiResultOfApplicationUser();
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApiResultOfApplicationUser>(<any>null);
    }
}

@Injectable({
    providedIn: 'root'
})
export class AccountManagmentService {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    resendVerificationMail(): Observable<ApiResultOfString> {
        let url_ = this.baseUrl + "/api/v1/account-managment/resend-verification-mail";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processResendVerificationMail(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processResendVerificationMail(<any>response_);
                } catch (e) {
                    return <Observable<ApiResultOfString>><any>_observableThrow(e);
                }
            } else
                return <Observable<ApiResultOfString>><any>_observableThrow(response_);
        }));
    }

    protected processResendVerificationMail(response: HttpResponseBase): Observable<ApiResultOfString> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ApiResultOfString.fromJS(resultData200) : new ApiResultOfString();
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = resultData400 ? ApiResultOfString.fromJS(resultData400) : new ApiResultOfString();
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApiResultOfString>(<any>null);
    }

    /**
     * @param code (optional) 
     * @return Success
     */
    verifyMail(code?: string | null | undefined): Observable<ApiResultOfString> {
        let url_ = this.baseUrl + "/api/v1/account-managment/verify-mail?";
        if (code !== undefined)
            url_ += "code=" + encodeURIComponent("" + code) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processVerifyMail(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processVerifyMail(<any>response_);
                } catch (e) {
                    return <Observable<ApiResultOfString>><any>_observableThrow(e);
                }
            } else
                return <Observable<ApiResultOfString>><any>_observableThrow(response_);
        }));
    }

    protected processVerifyMail(response: HttpResponseBase): Observable<ApiResultOfString> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ApiResultOfString.fromJS(resultData200) : new ApiResultOfString();
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = resultData400 ? ApiResultOfString.fromJS(resultData400) : new ApiResultOfString();
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApiResultOfString>(<any>null);
    }

    /**
     * @param model (optional) 
     * @return Success
     */
    changePassword(model?: ChangePasswordViewModel | null | undefined): Observable<ApiResultOfChangePasswordViewModel> {
        let url_ = this.baseUrl + "/api/v1/account-managment/change-password";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processChangePassword(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processChangePassword(<any>response_);
                } catch (e) {
                    return <Observable<ApiResultOfChangePasswordViewModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<ApiResultOfChangePasswordViewModel>><any>_observableThrow(response_);
        }));
    }

    protected processChangePassword(response: HttpResponseBase): Observable<ApiResultOfChangePasswordViewModel> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ApiResultOfChangePasswordViewModel.fromJS(resultData200) : new ApiResultOfChangePasswordViewModel();
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = resultData400 ? ApiResultOfChangePasswordViewModel.fromJS(resultData400) : new ApiResultOfChangePasswordViewModel();
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApiResultOfChangePasswordViewModel>(<any>null);
    }
}

@Injectable({
    providedIn: 'root'
})
export class FileUploadService {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    fileUploadGet(): Observable<ApiResultOfIEnumerableOfString> {
        let url_ = this.baseUrl + "/api/v1/file-upload";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFileUploadGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFileUploadGet(<any>response_);
                } catch (e) {
                    return <Observable<ApiResultOfIEnumerableOfString>><any>_observableThrow(e);
                }
            } else
                return <Observable<ApiResultOfIEnumerableOfString>><any>_observableThrow(response_);
        }));
    }

    protected processFileUploadGet(response: HttpResponseBase): Observable<ApiResultOfIEnumerableOfString> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ApiResultOfIEnumerableOfString.fromJS(resultData200) : new ApiResultOfIEnumerableOfString();
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = resultData400 ? ApiResultOfIEnumerableOfString.fromJS(resultData400) : new ApiResultOfIEnumerableOfString();
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApiResultOfIEnumerableOfString>(<any>null);
    }

    /**
     * @param contentType (optional) 
     * @param contentDisposition (optional) 
     * @param headers (optional) 
     * @param length (optional) 
     * @param name (optional) 
     * @param fileName (optional) 
     * @return Success
     */
    fileUploadPost(contentType?: string | null | undefined, contentDisposition?: string | null | undefined, headers?: any | null | undefined, length?: number | null | undefined, name?: string | null | undefined, fileName?: string | null | undefined): Observable<ApiResultOfIFormFile> {
        let url_ = this.baseUrl + "/api/v1/file-upload";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (contentType !== null && contentType !== undefined)
            content_.append("ContentType", contentType.toString());
        if (contentDisposition !== null && contentDisposition !== undefined)
            content_.append("ContentDisposition", contentDisposition.toString());
        if (headers !== null && headers !== undefined)
            content_.append("Headers", headers.toString());
        if (length !== null && length !== undefined)
            content_.append("Length", length.toString());
        if (name !== null && name !== undefined)
            content_.append("Name", name.toString());
        if (fileName !== null && fileName !== undefined)
            content_.append("FileName", fileName.toString());

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFileUploadPost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFileUploadPost(<any>response_);
                } catch (e) {
                    return <Observable<ApiResultOfIFormFile>><any>_observableThrow(e);
                }
            } else
                return <Observable<ApiResultOfIFormFile>><any>_observableThrow(response_);
        }));
    }

    protected processFileUploadPost(response: HttpResponseBase): Observable<ApiResultOfIFormFile> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ApiResultOfIFormFile.fromJS(resultData200) : new ApiResultOfIFormFile();
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = resultData400 ? ApiResultOfIFormFile.fromJS(resultData400) : new ApiResultOfIFormFile();
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApiResultOfIFormFile>(<any>null);
    }

    /**
     * @return Success
     */
    fileUploadDeleteWithid(id: string): Observable<ApiResultOfString> {
        let url_ = this.baseUrl + "/api/v1/file-upload/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFileUploadDeleteWithid(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFileUploadDeleteWithid(<any>response_);
                } catch (e) {
                    return <Observable<ApiResultOfString>><any>_observableThrow(e);
                }
            } else
                return <Observable<ApiResultOfString>><any>_observableThrow(response_);
        }));
    }

    protected processFileUploadDeleteWithid(response: HttpResponseBase): Observable<ApiResultOfString> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ApiResultOfString.fromJS(resultData200) : new ApiResultOfString();
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = resultData400 ? ApiResultOfString.fromJS(resultData400) : new ApiResultOfString();
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApiResultOfString>(<any>null);
    }
}

@Injectable({
    providedIn: 'root'
})
export class GameAccountService {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    gameAccountGet(): Observable<ApiResultOfIPagedListOfGameAccountViewModel> {
        let url_ = this.baseUrl + "/api/v1/game-account";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGameAccountGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGameAccountGet(<any>response_);
                } catch (e) {
                    return <Observable<ApiResultOfIPagedListOfGameAccountViewModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<ApiResultOfIPagedListOfGameAccountViewModel>><any>_observableThrow(response_);
        }));
    }

    protected processGameAccountGet(response: HttpResponseBase): Observable<ApiResultOfIPagedListOfGameAccountViewModel> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ApiResultOfIPagedListOfGameAccountViewModel.fromJS(resultData200) : new ApiResultOfIPagedListOfGameAccountViewModel();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApiResultOfIPagedListOfGameAccountViewModel>(<any>null);
    }

    /**
     * @param gameAccountViewModel (optional) 
     * @return Success
     */
    gameAccountPost(gameAccountViewModel?: GameAccountViewModel | null | undefined): Observable<ApiResultOfGameAccountViewModel> {
        let url_ = this.baseUrl + "/api/v1/game-account";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(gameAccountViewModel);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGameAccountPost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGameAccountPost(<any>response_);
                } catch (e) {
                    return <Observable<ApiResultOfGameAccountViewModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<ApiResultOfGameAccountViewModel>><any>_observableThrow(response_);
        }));
    }

    protected processGameAccountPost(response: HttpResponseBase): Observable<ApiResultOfGameAccountViewModel> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ApiResultOfGameAccountViewModel.fromJS(resultData200) : new ApiResultOfGameAccountViewModel();
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = resultData400 ? ApiResultOfGameAccountViewModel.fromJS(resultData400) : new ApiResultOfGameAccountViewModel();
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApiResultOfGameAccountViewModel>(<any>null);
    }

    /**
     * @param gameAccountViewModel (optional) 
     * @return Success
     */
    gameAccountPatch(gameAccountViewModel?: GameAccountViewModel | null | undefined): Observable<ApiResultOfGameAccountViewModel> {
        let url_ = this.baseUrl + "/api/v1/game-account";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(gameAccountViewModel);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("patch", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGameAccountPatch(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGameAccountPatch(<any>response_);
                } catch (e) {
                    return <Observable<ApiResultOfGameAccountViewModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<ApiResultOfGameAccountViewModel>><any>_observableThrow(response_);
        }));
    }

    protected processGameAccountPatch(response: HttpResponseBase): Observable<ApiResultOfGameAccountViewModel> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ApiResultOfGameAccountViewModel.fromJS(resultData200) : new ApiResultOfGameAccountViewModel();
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = resultData400 ? ApiResultOfGameAccountViewModel.fromJS(resultData400) : new ApiResultOfGameAccountViewModel();
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApiResultOfGameAccountViewModel>(<any>null);
    }

    /**
     * @return Success
     */
    gameAccountGetByid(id: string): Observable<ApiResultOfIPagedListOfGameAccountViewModel> {
        let url_ = this.baseUrl + "/api/v1/game-account/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGameAccountGetByid(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGameAccountGetByid(<any>response_);
                } catch (e) {
                    return <Observable<ApiResultOfIPagedListOfGameAccountViewModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<ApiResultOfIPagedListOfGameAccountViewModel>><any>_observableThrow(response_);
        }));
    }

    protected processGameAccountGetByid(response: HttpResponseBase): Observable<ApiResultOfIPagedListOfGameAccountViewModel> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ApiResultOfIPagedListOfGameAccountViewModel.fromJS(resultData200) : new ApiResultOfIPagedListOfGameAccountViewModel();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApiResultOfIPagedListOfGameAccountViewModel>(<any>null);
    }
}

@Injectable({
    providedIn: 'root'
})
export class GameEventService {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    gameEventsGet(): Observable<ApiResultOfObject> {
        let url_ = this.baseUrl + "/api/v1/game-events";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGameEventsGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGameEventsGet(<any>response_);
                } catch (e) {
                    return <Observable<ApiResultOfObject>><any>_observableThrow(e);
                }
            } else
                return <Observable<ApiResultOfObject>><any>_observableThrow(response_);
        }));
    }

    protected processGameEventsGet(response: HttpResponseBase): Observable<ApiResultOfObject> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ApiResultOfObject.fromJS(resultData200) : new ApiResultOfObject();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApiResultOfObject>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    gameEventsPatch(id?: string | null | undefined): Observable<ApiResultOfGuid> {
        let url_ = this.baseUrl + "/api/v1/game-events";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(id);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("patch", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGameEventsPatch(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGameEventsPatch(<any>response_);
                } catch (e) {
                    return <Observable<ApiResultOfGuid>><any>_observableThrow(e);
                }
            } else
                return <Observable<ApiResultOfGuid>><any>_observableThrow(response_);
        }));
    }

    protected processGameEventsPatch(response: HttpResponseBase): Observable<ApiResultOfGuid> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ApiResultOfGuid.fromJS(resultData200) : new ApiResultOfGuid();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApiResultOfGuid>(<any>null);
    }
}

@Injectable({
    providedIn: 'root'
})
export class NewsService {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param index (optional) 
     * @param count (optional) 
     * @return Success
     */
    unpublished(index?: number | null | undefined, count?: number | null | undefined): Observable<ApiResultOfPagedResultDataOfIEnumerableOfNewsPostViewModel> {
        let url_ = this.baseUrl + "/api/v1/news/unpublished?";
        if (index !== undefined)
            url_ += "index=" + encodeURIComponent("" + index) + "&"; 
        if (count !== undefined)
            url_ += "count=" + encodeURIComponent("" + count) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUnpublished(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUnpublished(<any>response_);
                } catch (e) {
                    return <Observable<ApiResultOfPagedResultDataOfIEnumerableOfNewsPostViewModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<ApiResultOfPagedResultDataOfIEnumerableOfNewsPostViewModel>><any>_observableThrow(response_);
        }));
    }

    protected processUnpublished(response: HttpResponseBase): Observable<ApiResultOfPagedResultDataOfIEnumerableOfNewsPostViewModel> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ApiResultOfPagedResultDataOfIEnumerableOfNewsPostViewModel.fromJS(resultData200) : new ApiResultOfPagedResultDataOfIEnumerableOfNewsPostViewModel();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApiResultOfPagedResultDataOfIEnumerableOfNewsPostViewModel>(<any>null);
    }

    /**
     * @param index (optional) 
     * @param count (optional) 
     * @return Success
     */
    newsGet(index?: number | null | undefined, count?: number | null | undefined): Observable<ApiResultOfPagedResultDataOfIEnumerableOfNewsPostViewModel> {
        let url_ = this.baseUrl + "/api/v1/news?";
        if (index !== undefined)
            url_ += "index=" + encodeURIComponent("" + index) + "&"; 
        if (count !== undefined)
            url_ += "count=" + encodeURIComponent("" + count) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processNewsGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processNewsGet(<any>response_);
                } catch (e) {
                    return <Observable<ApiResultOfPagedResultDataOfIEnumerableOfNewsPostViewModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<ApiResultOfPagedResultDataOfIEnumerableOfNewsPostViewModel>><any>_observableThrow(response_);
        }));
    }

    protected processNewsGet(response: HttpResponseBase): Observable<ApiResultOfPagedResultDataOfIEnumerableOfNewsPostViewModel> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ApiResultOfPagedResultDataOfIEnumerableOfNewsPostViewModel.fromJS(resultData200) : new ApiResultOfPagedResultDataOfIEnumerableOfNewsPostViewModel();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApiResultOfPagedResultDataOfIEnumerableOfNewsPostViewModel>(<any>null);
    }

    /**
     * @param newsViewModel (optional) 
     * @return Success
     */
    newsPost(newsViewModel?: NewsPostViewModel | null | undefined): Observable<ApiResultOfNewsPostViewModel> {
        let url_ = this.baseUrl + "/api/v1/news";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(newsViewModel);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processNewsPost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processNewsPost(<any>response_);
                } catch (e) {
                    return <Observable<ApiResultOfNewsPostViewModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<ApiResultOfNewsPostViewModel>><any>_observableThrow(response_);
        }));
    }

    protected processNewsPost(response: HttpResponseBase): Observable<ApiResultOfNewsPostViewModel> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ApiResultOfNewsPostViewModel.fromJS(resultData200) : new ApiResultOfNewsPostViewModel();
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = resultData400 ? ApiResultOfNewsPostViewModel.fromJS(resultData400) : new ApiResultOfNewsPostViewModel();
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApiResultOfNewsPostViewModel>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    newsDelete(id?: string | null | undefined): Observable<ApiResultOfGuid> {
        let url_ = this.baseUrl + "/api/v1/news?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processNewsDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processNewsDelete(<any>response_);
                } catch (e) {
                    return <Observable<ApiResultOfGuid>><any>_observableThrow(e);
                }
            } else
                return <Observable<ApiResultOfGuid>><any>_observableThrow(response_);
        }));
    }

    protected processNewsDelete(response: HttpResponseBase): Observable<ApiResultOfGuid> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ApiResultOfGuid.fromJS(resultData200) : new ApiResultOfGuid();
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = resultData400 ? ApiResultOfGuid.fromJS(resultData400) : new ApiResultOfGuid();
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApiResultOfGuid>(<any>null);
    }

    /**
     * @param newsViewModel (optional) 
     * @return Success
     */
    newsPatch(newsViewModel?: NewsPostViewModel | null | undefined): Observable<ApiResultOfNewsPostViewModel> {
        let url_ = this.baseUrl + "/api/v1/news";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(newsViewModel);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("patch", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processNewsPatch(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processNewsPatch(<any>response_);
                } catch (e) {
                    return <Observable<ApiResultOfNewsPostViewModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<ApiResultOfNewsPostViewModel>><any>_observableThrow(response_);
        }));
    }

    protected processNewsPatch(response: HttpResponseBase): Observable<ApiResultOfNewsPostViewModel> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ApiResultOfNewsPostViewModel.fromJS(resultData200) : new ApiResultOfNewsPostViewModel();
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = resultData400 ? ApiResultOfNewsPostViewModel.fromJS(resultData400) : new ApiResultOfNewsPostViewModel();
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApiResultOfNewsPostViewModel>(<any>null);
    }

    /**
     * @return Success
     */
    newsGetByid(id: string): Observable<ApiResultOfNewsPostViewModel> {
        let url_ = this.baseUrl + "/api/v1/news/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processNewsGetByid(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processNewsGetByid(<any>response_);
                } catch (e) {
                    return <Observable<ApiResultOfNewsPostViewModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<ApiResultOfNewsPostViewModel>><any>_observableThrow(response_);
        }));
    }

    protected processNewsGetByid(response: HttpResponseBase): Observable<ApiResultOfNewsPostViewModel> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ApiResultOfNewsPostViewModel.fromJS(resultData200) : new ApiResultOfNewsPostViewModel();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApiResultOfNewsPostViewModel>(<any>null);
    }
}

@Injectable({
    providedIn: 'root'
})
export class RolesService {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    rolesGetByid(id: string): Observable<ApiResultOfStringOf> {
        let url_ = this.baseUrl + "/api/v1/roles/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRolesGetByid(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRolesGetByid(<any>response_);
                } catch (e) {
                    return <Observable<ApiResultOfStringOf>><any>_observableThrow(e);
                }
            } else
                return <Observable<ApiResultOfStringOf>><any>_observableThrow(response_);
        }));
    }

    protected processRolesGetByid(response: HttpResponseBase): Observable<ApiResultOfStringOf> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ApiResultOfStringOf.fromJS(resultData200) : new ApiResultOfStringOf();
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = resultData400 ? ApiResultOfStringOf.fromJS(resultData400) : new ApiResultOfStringOf();
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApiResultOfStringOf>(<any>null);
    }

    /**
     * @param rolesViewModel (optional) 
     * @return Success
     */
    roles(rolesViewModel?: UpdateRolesViewModel | null | undefined): Observable<ApiResultOfUpdateRolesViewModel> {
        let url_ = this.baseUrl + "/api/v1/roles";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(rolesViewModel);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("patch", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRoles(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRoles(<any>response_);
                } catch (e) {
                    return <Observable<ApiResultOfUpdateRolesViewModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<ApiResultOfUpdateRolesViewModel>><any>_observableThrow(response_);
        }));
    }

    protected processRoles(response: HttpResponseBase): Observable<ApiResultOfUpdateRolesViewModel> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ApiResultOfUpdateRolesViewModel.fromJS(resultData200) : new ApiResultOfUpdateRolesViewModel();
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = resultData400 ? ApiResultOfUpdateRolesViewModel.fromJS(resultData400) : new ApiResultOfUpdateRolesViewModel();
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApiResultOfUpdateRolesViewModel>(<any>null);
    }
}

@Injectable({
    providedIn: 'root'
})
export class ServiceStatusService {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    recentHidden(): Observable<ApiResultOfIEnumerableOfServiceStatusViewModel> {
        let url_ = this.baseUrl + "/api/v1/service-status/recent-hidden";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRecentHidden(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRecentHidden(<any>response_);
                } catch (e) {
                    return <Observable<ApiResultOfIEnumerableOfServiceStatusViewModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<ApiResultOfIEnumerableOfServiceStatusViewModel>><any>_observableThrow(response_);
        }));
    }

    protected processRecentHidden(response: HttpResponseBase): Observable<ApiResultOfIEnumerableOfServiceStatusViewModel> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ApiResultOfIEnumerableOfServiceStatusViewModel.fromJS(resultData200) : new ApiResultOfIEnumerableOfServiceStatusViewModel();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApiResultOfIEnumerableOfServiceStatusViewModel>(<any>null);
    }

    /**
     * @param model (optional) 
     * @return Success
     */
    serviceStatusPost(model?: ServiceStatusViewModel | null | undefined): Observable<ApiResultOfServiceStatusViewModel> {
        let url_ = this.baseUrl + "/api/v1/service-status";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processServiceStatusPost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processServiceStatusPost(<any>response_);
                } catch (e) {
                    return <Observable<ApiResultOfServiceStatusViewModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<ApiResultOfServiceStatusViewModel>><any>_observableThrow(response_);
        }));
    }

    protected processServiceStatusPost(response: HttpResponseBase): Observable<ApiResultOfServiceStatusViewModel> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ApiResultOfServiceStatusViewModel.fromJS(resultData200) : new ApiResultOfServiceStatusViewModel();
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = resultData400 ? ApiResultOfServiceStatusViewModel.fromJS(resultData400) : new ApiResultOfServiceStatusViewModel();
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApiResultOfServiceStatusViewModel>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    serviceStatusDelete(id?: string | null | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/v1/service-status?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processServiceStatusDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processServiceStatusDelete(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processServiceStatusDelete(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }

    /**
     * @param model (optional) 
     * @return Success
     */
    serviceStatusPatch(model?: ServiceStatusViewModel | null | undefined): Observable<ApiResultOfServiceStatusViewModel> {
        let url_ = this.baseUrl + "/api/v1/service-status";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("patch", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processServiceStatusPatch(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processServiceStatusPatch(<any>response_);
                } catch (e) {
                    return <Observable<ApiResultOfServiceStatusViewModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<ApiResultOfServiceStatusViewModel>><any>_observableThrow(response_);
        }));
    }

    protected processServiceStatusPatch(response: HttpResponseBase): Observable<ApiResultOfServiceStatusViewModel> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ApiResultOfServiceStatusViewModel.fromJS(resultData200) : new ApiResultOfServiceStatusViewModel();
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = resultData400 ? ApiResultOfServiceStatusViewModel.fromJS(resultData400) : new ApiResultOfServiceStatusViewModel();
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApiResultOfServiceStatusViewModel>(<any>null);
    }
}

export class LoginViewModel implements ILoginViewModel {
    email!: string;
    password!: string;
    rememberMe?: boolean | null;

    constructor(data?: ILoginViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.email = data["email"] !== undefined ? data["email"] : <any>null;
            this.password = data["password"] !== undefined ? data["password"] : <any>null;
            this.rememberMe = data["rememberMe"] !== undefined ? data["rememberMe"] : <any>null;
        }
    }

    static fromJS(data: any): LoginViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new LoginViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["email"] = this.email !== undefined ? this.email : <any>null;
        data["password"] = this.password !== undefined ? this.password : <any>null;
        data["rememberMe"] = this.rememberMe !== undefined ? this.rememberMe : <any>null;
        return data; 
    }
}

export interface ILoginViewModel {
    email: string;
    password: string;
    rememberMe?: boolean | null;
}

export class ApiResultOfString implements IApiResultOfString {
    data?: string | null;
    success?: boolean | null;
    errors?: string[] | null;

    constructor(data?: IApiResultOfString) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.data = data["data"] !== undefined ? data["data"] : <any>null;
            this.success = data["success"] !== undefined ? data["success"] : <any>null;
            if (data["errors"] && data["errors"].constructor === Array) {
                this.errors = [] as any;
                for (let item of data["errors"])
                    this.errors!.push(item);
            }
        }
    }

    static fromJS(data: any): ApiResultOfString {
        data = typeof data === 'object' ? data : {};
        let result = new ApiResultOfString();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data"] = this.data !== undefined ? this.data : <any>null;
        data["success"] = this.success !== undefined ? this.success : <any>null;
        if (this.errors && this.errors.constructor === Array) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        return data; 
    }
}

export interface IApiResultOfString {
    data?: string | null;
    success?: boolean | null;
    errors?: string[] | null;
}

export class ApiResultOfLoginViewModel implements IApiResultOfLoginViewModel {
    data?: LoginViewModel | null;
    success?: boolean | null;
    errors?: string[] | null;

    constructor(data?: IApiResultOfLoginViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.data = data["data"] ? LoginViewModel.fromJS(data["data"]) : <any>null;
            this.success = data["success"] !== undefined ? data["success"] : <any>null;
            if (data["errors"] && data["errors"].constructor === Array) {
                this.errors = [] as any;
                for (let item of data["errors"])
                    this.errors!.push(item);
            }
        }
    }

    static fromJS(data: any): ApiResultOfLoginViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new ApiResultOfLoginViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data"] = this.data ? this.data.toJSON() : <any>null;
        data["success"] = this.success !== undefined ? this.success : <any>null;
        if (this.errors && this.errors.constructor === Array) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        return data; 
    }
}

export interface IApiResultOfLoginViewModel {
    data?: LoginViewModel | null;
    success?: boolean | null;
    errors?: string[] | null;
}

export class RegisterViewModel implements IRegisterViewModel {
    email!: string;
    password!: string;
    confirmPassword?: string | null;

    constructor(data?: IRegisterViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.email = data["email"] !== undefined ? data["email"] : <any>null;
            this.password = data["password"] !== undefined ? data["password"] : <any>null;
            this.confirmPassword = data["confirmPassword"] !== undefined ? data["confirmPassword"] : <any>null;
        }
    }

    static fromJS(data: any): RegisterViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new RegisterViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["email"] = this.email !== undefined ? this.email : <any>null;
        data["password"] = this.password !== undefined ? this.password : <any>null;
        data["confirmPassword"] = this.confirmPassword !== undefined ? this.confirmPassword : <any>null;
        return data; 
    }
}

export interface IRegisterViewModel {
    email: string;
    password: string;
    confirmPassword?: string | null;
}

export class ApiResultOfRegisterViewModel implements IApiResultOfRegisterViewModel {
    data?: RegisterViewModel | null;
    success?: boolean | null;
    errors?: string[] | null;

    constructor(data?: IApiResultOfRegisterViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.data = data["data"] ? RegisterViewModel.fromJS(data["data"]) : <any>null;
            this.success = data["success"] !== undefined ? data["success"] : <any>null;
            if (data["errors"] && data["errors"].constructor === Array) {
                this.errors = [] as any;
                for (let item of data["errors"])
                    this.errors!.push(item);
            }
        }
    }

    static fromJS(data: any): ApiResultOfRegisterViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new ApiResultOfRegisterViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data"] = this.data ? this.data.toJSON() : <any>null;
        data["success"] = this.success !== undefined ? this.success : <any>null;
        if (this.errors && this.errors.constructor === Array) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        return data; 
    }
}

export interface IApiResultOfRegisterViewModel {
    data?: RegisterViewModel | null;
    success?: boolean | null;
    errors?: string[] | null;
}

export class ApiResultOfPagedResultDataOfIEnumerableOfApplicationUser implements IApiResultOfPagedResultDataOfIEnumerableOfApplicationUser {
    data?: PagedResultDataOfIEnumerableOfApplicationUser | null;
    success?: boolean | null;
    errors?: string[] | null;

    constructor(data?: IApiResultOfPagedResultDataOfIEnumerableOfApplicationUser) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.data = data["data"] ? PagedResultDataOfIEnumerableOfApplicationUser.fromJS(data["data"]) : <any>null;
            this.success = data["success"] !== undefined ? data["success"] : <any>null;
            if (data["errors"] && data["errors"].constructor === Array) {
                this.errors = [] as any;
                for (let item of data["errors"])
                    this.errors!.push(item);
            }
        }
    }

    static fromJS(data: any): ApiResultOfPagedResultDataOfIEnumerableOfApplicationUser {
        data = typeof data === 'object' ? data : {};
        let result = new ApiResultOfPagedResultDataOfIEnumerableOfApplicationUser();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data"] = this.data ? this.data.toJSON() : <any>null;
        data["success"] = this.success !== undefined ? this.success : <any>null;
        if (this.errors && this.errors.constructor === Array) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        return data; 
    }
}

export interface IApiResultOfPagedResultDataOfIEnumerableOfApplicationUser {
    data?: PagedResultDataOfIEnumerableOfApplicationUser | null;
    success?: boolean | null;
    errors?: string[] | null;
}

export class PagedResultDataOfIEnumerableOfApplicationUser implements IPagedResultDataOfIEnumerableOfApplicationUser {
    content?: ApplicationUser[] | null;
    recordCount?: number | null;
    currentIndex?: number | null;
    currentCountPerPage?: number | null;
    pageCount?: number | null;

    constructor(data?: IPagedResultDataOfIEnumerableOfApplicationUser) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["content"] && data["content"].constructor === Array) {
                this.content = [] as any;
                for (let item of data["content"])
                    this.content!.push(ApplicationUser.fromJS(item));
            }
            this.recordCount = data["recordCount"] !== undefined ? data["recordCount"] : <any>null;
            this.currentIndex = data["currentIndex"] !== undefined ? data["currentIndex"] : <any>null;
            this.currentCountPerPage = data["currentCountPerPage"] !== undefined ? data["currentCountPerPage"] : <any>null;
            this.pageCount = data["pageCount"] !== undefined ? data["pageCount"] : <any>null;
        }
    }

    static fromJS(data: any): PagedResultDataOfIEnumerableOfApplicationUser {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDataOfIEnumerableOfApplicationUser();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.content && this.content.constructor === Array) {
            data["content"] = [];
            for (let item of this.content)
                data["content"].push(item.toJSON());
        }
        data["recordCount"] = this.recordCount !== undefined ? this.recordCount : <any>null;
        data["currentIndex"] = this.currentIndex !== undefined ? this.currentIndex : <any>null;
        data["currentCountPerPage"] = this.currentCountPerPage !== undefined ? this.currentCountPerPage : <any>null;
        data["pageCount"] = this.pageCount !== undefined ? this.pageCount : <any>null;
        return data; 
    }
}

export interface IPagedResultDataOfIEnumerableOfApplicationUser {
    content?: ApplicationUser[] | null;
    recordCount?: number | null;
    currentIndex?: number | null;
    currentCountPerPage?: number | null;
    pageCount?: number | null;
}

export class ApplicationUser implements IApplicationUser {
    id?: string | null;
    userName?: string | null;
    normalizedUserName?: string | null;
    email?: string | null;
    normalizedEmail?: string | null;
    emailConfirmed?: boolean | null;
    passwordHash?: string | null;
    securityStamp?: string | null;
    concurrencyStamp?: string | null;
    phoneNumber?: string | null;
    phoneNumberConfirmed?: boolean | null;
    twoFactorEnabled?: boolean | null;
    lockoutEnd?: Date | null;
    lockoutEnabled?: boolean | null;
    accessFailedCount?: number | null;

    constructor(data?: IApplicationUser) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"] !== undefined ? data["id"] : <any>null;
            this.userName = data["userName"] !== undefined ? data["userName"] : <any>null;
            this.normalizedUserName = data["normalizedUserName"] !== undefined ? data["normalizedUserName"] : <any>null;
            this.email = data["email"] !== undefined ? data["email"] : <any>null;
            this.normalizedEmail = data["normalizedEmail"] !== undefined ? data["normalizedEmail"] : <any>null;
            this.emailConfirmed = data["emailConfirmed"] !== undefined ? data["emailConfirmed"] : <any>null;
            this.passwordHash = data["passwordHash"] !== undefined ? data["passwordHash"] : <any>null;
            this.securityStamp = data["securityStamp"] !== undefined ? data["securityStamp"] : <any>null;
            this.concurrencyStamp = data["concurrencyStamp"] !== undefined ? data["concurrencyStamp"] : <any>null;
            this.phoneNumber = data["phoneNumber"] !== undefined ? data["phoneNumber"] : <any>null;
            this.phoneNumberConfirmed = data["phoneNumberConfirmed"] !== undefined ? data["phoneNumberConfirmed"] : <any>null;
            this.twoFactorEnabled = data["twoFactorEnabled"] !== undefined ? data["twoFactorEnabled"] : <any>null;
            this.lockoutEnd = data["lockoutEnd"] ? new Date(data["lockoutEnd"].toString()) : <any>null;
            this.lockoutEnabled = data["lockoutEnabled"] !== undefined ? data["lockoutEnabled"] : <any>null;
            this.accessFailedCount = data["accessFailedCount"] !== undefined ? data["accessFailedCount"] : <any>null;
        }
    }

    static fromJS(data: any): ApplicationUser {
        data = typeof data === 'object' ? data : {};
        let result = new ApplicationUser();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["userName"] = this.userName !== undefined ? this.userName : <any>null;
        data["normalizedUserName"] = this.normalizedUserName !== undefined ? this.normalizedUserName : <any>null;
        data["email"] = this.email !== undefined ? this.email : <any>null;
        data["normalizedEmail"] = this.normalizedEmail !== undefined ? this.normalizedEmail : <any>null;
        data["emailConfirmed"] = this.emailConfirmed !== undefined ? this.emailConfirmed : <any>null;
        data["passwordHash"] = this.passwordHash !== undefined ? this.passwordHash : <any>null;
        data["securityStamp"] = this.securityStamp !== undefined ? this.securityStamp : <any>null;
        data["concurrencyStamp"] = this.concurrencyStamp !== undefined ? this.concurrencyStamp : <any>null;
        data["phoneNumber"] = this.phoneNumber !== undefined ? this.phoneNumber : <any>null;
        data["phoneNumberConfirmed"] = this.phoneNumberConfirmed !== undefined ? this.phoneNumberConfirmed : <any>null;
        data["twoFactorEnabled"] = this.twoFactorEnabled !== undefined ? this.twoFactorEnabled : <any>null;
        data["lockoutEnd"] = this.lockoutEnd ? this.lockoutEnd.toISOString() : <any>null;
        data["lockoutEnabled"] = this.lockoutEnabled !== undefined ? this.lockoutEnabled : <any>null;
        data["accessFailedCount"] = this.accessFailedCount !== undefined ? this.accessFailedCount : <any>null;
        return data; 
    }
}

export interface IApplicationUser {
    id?: string | null;
    userName?: string | null;
    normalizedUserName?: string | null;
    email?: string | null;
    normalizedEmail?: string | null;
    emailConfirmed?: boolean | null;
    passwordHash?: string | null;
    securityStamp?: string | null;
    concurrencyStamp?: string | null;
    phoneNumber?: string | null;
    phoneNumberConfirmed?: boolean | null;
    twoFactorEnabled?: boolean | null;
    lockoutEnd?: Date | null;
    lockoutEnabled?: boolean | null;
    accessFailedCount?: number | null;
}

export class ApiResultOfApplicationUser implements IApiResultOfApplicationUser {
    data?: ApplicationUser | null;
    success?: boolean | null;
    errors?: string[] | null;

    constructor(data?: IApiResultOfApplicationUser) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.data = data["data"] ? ApplicationUser.fromJS(data["data"]) : <any>null;
            this.success = data["success"] !== undefined ? data["success"] : <any>null;
            if (data["errors"] && data["errors"].constructor === Array) {
                this.errors = [] as any;
                for (let item of data["errors"])
                    this.errors!.push(item);
            }
        }
    }

    static fromJS(data: any): ApiResultOfApplicationUser {
        data = typeof data === 'object' ? data : {};
        let result = new ApiResultOfApplicationUser();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data"] = this.data ? this.data.toJSON() : <any>null;
        data["success"] = this.success !== undefined ? this.success : <any>null;
        if (this.errors && this.errors.constructor === Array) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        return data; 
    }
}

export interface IApiResultOfApplicationUser {
    data?: ApplicationUser | null;
    success?: boolean | null;
    errors?: string[] | null;
}

export class ChangePasswordViewModel implements IChangePasswordViewModel {
    oldPassword!: string;
    newPassword!: string;
    confirmPassword?: string | null;
    statusMessage?: string | null;

    constructor(data?: IChangePasswordViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.oldPassword = data["oldPassword"] !== undefined ? data["oldPassword"] : <any>null;
            this.newPassword = data["newPassword"] !== undefined ? data["newPassword"] : <any>null;
            this.confirmPassword = data["confirmPassword"] !== undefined ? data["confirmPassword"] : <any>null;
            this.statusMessage = data["statusMessage"] !== undefined ? data["statusMessage"] : <any>null;
        }
    }

    static fromJS(data: any): ChangePasswordViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new ChangePasswordViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["oldPassword"] = this.oldPassword !== undefined ? this.oldPassword : <any>null;
        data["newPassword"] = this.newPassword !== undefined ? this.newPassword : <any>null;
        data["confirmPassword"] = this.confirmPassword !== undefined ? this.confirmPassword : <any>null;
        data["statusMessage"] = this.statusMessage !== undefined ? this.statusMessage : <any>null;
        return data; 
    }
}

export interface IChangePasswordViewModel {
    oldPassword: string;
    newPassword: string;
    confirmPassword?: string | null;
    statusMessage?: string | null;
}

export class ApiResultOfChangePasswordViewModel implements IApiResultOfChangePasswordViewModel {
    data?: ChangePasswordViewModel | null;
    success?: boolean | null;
    errors?: string[] | null;

    constructor(data?: IApiResultOfChangePasswordViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.data = data["data"] ? ChangePasswordViewModel.fromJS(data["data"]) : <any>null;
            this.success = data["success"] !== undefined ? data["success"] : <any>null;
            if (data["errors"] && data["errors"].constructor === Array) {
                this.errors = [] as any;
                for (let item of data["errors"])
                    this.errors!.push(item);
            }
        }
    }

    static fromJS(data: any): ApiResultOfChangePasswordViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new ApiResultOfChangePasswordViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data"] = this.data ? this.data.toJSON() : <any>null;
        data["success"] = this.success !== undefined ? this.success : <any>null;
        if (this.errors && this.errors.constructor === Array) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        return data; 
    }
}

export interface IApiResultOfChangePasswordViewModel {
    data?: ChangePasswordViewModel | null;
    success?: boolean | null;
    errors?: string[] | null;
}

export class ApiResultOfIEnumerableOfString implements IApiResultOfIEnumerableOfString {
    data?: string[] | null;
    success?: boolean | null;
    errors?: string[] | null;

    constructor(data?: IApiResultOfIEnumerableOfString) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["data"] && data["data"].constructor === Array) {
                this.data = [] as any;
                for (let item of data["data"])
                    this.data!.push(item);
            }
            this.success = data["success"] !== undefined ? data["success"] : <any>null;
            if (data["errors"] && data["errors"].constructor === Array) {
                this.errors = [] as any;
                for (let item of data["errors"])
                    this.errors!.push(item);
            }
        }
    }

    static fromJS(data: any): ApiResultOfIEnumerableOfString {
        data = typeof data === 'object' ? data : {};
        let result = new ApiResultOfIEnumerableOfString();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.data && this.data.constructor === Array) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item);
        }
        data["success"] = this.success !== undefined ? this.success : <any>null;
        if (this.errors && this.errors.constructor === Array) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        return data; 
    }
}

export interface IApiResultOfIEnumerableOfString {
    data?: string[] | null;
    success?: boolean | null;
    errors?: string[] | null;
}

export class ApiResultOfIFormFile implements IApiResultOfIFormFile {
    data?: IFormFile | null;
    success?: boolean | null;
    errors?: string[] | null;

    constructor(data?: IApiResultOfIFormFile) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.data = data["data"] ? IFormFile.fromJS(data["data"]) : <any>null;
            this.success = data["success"] !== undefined ? data["success"] : <any>null;
            if (data["errors"] && data["errors"].constructor === Array) {
                this.errors = [] as any;
                for (let item of data["errors"])
                    this.errors!.push(item);
            }
        }
    }

    static fromJS(data: any): ApiResultOfIFormFile {
        data = typeof data === 'object' ? data : {};
        let result = new ApiResultOfIFormFile();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data"] = this.data ? this.data.toJSON() : <any>null;
        data["success"] = this.success !== undefined ? this.success : <any>null;
        if (this.errors && this.errors.constructor === Array) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        return data; 
    }
}

export interface IApiResultOfIFormFile {
    data?: IFormFile | null;
    success?: boolean | null;
    errors?: string[] | null;
}

export class IFormFile implements IIFormFile {
    contentType?: string | null;
    contentDisposition?: string | null;
    headers?: { [key: string] : string[]; } | null;
    length?: number | null;
    name?: string | null;
    fileName?: string | null;

    constructor(data?: IIFormFile) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.contentType = data["contentType"] !== undefined ? data["contentType"] : <any>null;
            this.contentDisposition = data["contentDisposition"] !== undefined ? data["contentDisposition"] : <any>null;
            if (data["headers"]) {
                this.headers = {} as any;
                for (let key in data["headers"]) {
                    if (data["headers"].hasOwnProperty(key))
                        this.headers![key] = data["headers"][key] !== undefined ? data["headers"][key] : [];
                }
            }
            this.length = data["length"] !== undefined ? data["length"] : <any>null;
            this.name = data["name"] !== undefined ? data["name"] : <any>null;
            this.fileName = data["fileName"] !== undefined ? data["fileName"] : <any>null;
        }
    }

    static fromJS(data: any): IFormFile {
        data = typeof data === 'object' ? data : {};
        let result = new IFormFile();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["contentType"] = this.contentType !== undefined ? this.contentType : <any>null;
        data["contentDisposition"] = this.contentDisposition !== undefined ? this.contentDisposition : <any>null;
        if (this.headers) {
            data["headers"] = {};
            for (let key in this.headers) {
                if (this.headers.hasOwnProperty(key))
                    data["headers"][key] = this.headers[key] !== undefined ? this.headers[key] : <any>null;
            }
        }
        data["length"] = this.length !== undefined ? this.length : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["fileName"] = this.fileName !== undefined ? this.fileName : <any>null;
        return data; 
    }
}

export interface IIFormFile {
    contentType?: string | null;
    contentDisposition?: string | null;
    headers?: { [key: string] : string[]; } | null;
    length?: number | null;
    name?: string | null;
    fileName?: string | null;
}

export class GameAccountViewModel implements IGameAccountViewModel {
    id?: string | null;
    alias!: string;
    account?: string | null;

    constructor(data?: IGameAccountViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"] !== undefined ? data["id"] : <any>null;
            this.alias = data["alias"] !== undefined ? data["alias"] : <any>null;
            this.account = data["account"] !== undefined ? data["account"] : <any>null;
        }
    }

    static fromJS(data: any): GameAccountViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new GameAccountViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["alias"] = this.alias !== undefined ? this.alias : <any>null;
        data["account"] = this.account !== undefined ? this.account : <any>null;
        return data; 
    }
}

export interface IGameAccountViewModel {
    id?: string | null;
    alias: string;
    account?: string | null;
}

export class ApiResultOfGameAccountViewModel implements IApiResultOfGameAccountViewModel {
    data?: GameAccountViewModel | null;
    success?: boolean | null;
    errors?: string[] | null;

    constructor(data?: IApiResultOfGameAccountViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.data = data["data"] ? GameAccountViewModel.fromJS(data["data"]) : <any>null;
            this.success = data["success"] !== undefined ? data["success"] : <any>null;
            if (data["errors"] && data["errors"].constructor === Array) {
                this.errors = [] as any;
                for (let item of data["errors"])
                    this.errors!.push(item);
            }
        }
    }

    static fromJS(data: any): ApiResultOfGameAccountViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new ApiResultOfGameAccountViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data"] = this.data ? this.data.toJSON() : <any>null;
        data["success"] = this.success !== undefined ? this.success : <any>null;
        if (this.errors && this.errors.constructor === Array) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        return data; 
    }
}

export interface IApiResultOfGameAccountViewModel {
    data?: GameAccountViewModel | null;
    success?: boolean | null;
    errors?: string[] | null;
}

export class ApiResultOfIPagedListOfGameAccountViewModel implements IApiResultOfIPagedListOfGameAccountViewModel {
    data?: GameAccountViewModel[] | null;
    success?: boolean | null;
    errors?: string[] | null;

    constructor(data?: IApiResultOfIPagedListOfGameAccountViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["data"] && data["data"].constructor === Array) {
                this.data = [] as any;
                for (let item of data["data"])
                    this.data!.push(GameAccountViewModel.fromJS(item));
            }
            this.success = data["success"] !== undefined ? data["success"] : <any>null;
            if (data["errors"] && data["errors"].constructor === Array) {
                this.errors = [] as any;
                for (let item of data["errors"])
                    this.errors!.push(item);
            }
        }
    }

    static fromJS(data: any): ApiResultOfIPagedListOfGameAccountViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new ApiResultOfIPagedListOfGameAccountViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.data && this.data.constructor === Array) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["success"] = this.success !== undefined ? this.success : <any>null;
        if (this.errors && this.errors.constructor === Array) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        return data; 
    }
}

export interface IApiResultOfIPagedListOfGameAccountViewModel {
    data?: GameAccountViewModel[] | null;
    success?: boolean | null;
    errors?: string[] | null;
}

export class ApiResultOfObject implements IApiResultOfObject {
    data?: any | null;
    success?: boolean | null;
    errors?: string[] | null;

    constructor(data?: IApiResultOfObject) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.data = data["data"] !== undefined ? data["data"] : <any>null;
            this.success = data["success"] !== undefined ? data["success"] : <any>null;
            if (data["errors"] && data["errors"].constructor === Array) {
                this.errors = [] as any;
                for (let item of data["errors"])
                    this.errors!.push(item);
            }
        }
    }

    static fromJS(data: any): ApiResultOfObject {
        data = typeof data === 'object' ? data : {};
        let result = new ApiResultOfObject();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data"] = this.data !== undefined ? this.data : <any>null;
        data["success"] = this.success !== undefined ? this.success : <any>null;
        if (this.errors && this.errors.constructor === Array) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        return data; 
    }
}

export interface IApiResultOfObject {
    data?: any | null;
    success?: boolean | null;
    errors?: string[] | null;
}

export class ApiResultOfGuid implements IApiResultOfGuid {
    data?: string | null;
    success?: boolean | null;
    errors?: string[] | null;

    constructor(data?: IApiResultOfGuid) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.data = data["data"] !== undefined ? data["data"] : <any>null;
            this.success = data["success"] !== undefined ? data["success"] : <any>null;
            if (data["errors"] && data["errors"].constructor === Array) {
                this.errors = [] as any;
                for (let item of data["errors"])
                    this.errors!.push(item);
            }
        }
    }

    static fromJS(data: any): ApiResultOfGuid {
        data = typeof data === 'object' ? data : {};
        let result = new ApiResultOfGuid();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data"] = this.data !== undefined ? this.data : <any>null;
        data["success"] = this.success !== undefined ? this.success : <any>null;
        if (this.errors && this.errors.constructor === Array) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        return data; 
    }
}

export interface IApiResultOfGuid {
    data?: string | null;
    success?: boolean | null;
    errors?: string[] | null;
}

export class ApiResultOfPagedResultDataOfIEnumerableOfNewsPostViewModel implements IApiResultOfPagedResultDataOfIEnumerableOfNewsPostViewModel {
    data?: PagedResultDataOfIEnumerableOfNewsPostViewModel | null;
    success?: boolean | null;
    errors?: string[] | null;

    constructor(data?: IApiResultOfPagedResultDataOfIEnumerableOfNewsPostViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.data = data["data"] ? PagedResultDataOfIEnumerableOfNewsPostViewModel.fromJS(data["data"]) : <any>null;
            this.success = data["success"] !== undefined ? data["success"] : <any>null;
            if (data["errors"] && data["errors"].constructor === Array) {
                this.errors = [] as any;
                for (let item of data["errors"])
                    this.errors!.push(item);
            }
        }
    }

    static fromJS(data: any): ApiResultOfPagedResultDataOfIEnumerableOfNewsPostViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new ApiResultOfPagedResultDataOfIEnumerableOfNewsPostViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data"] = this.data ? this.data.toJSON() : <any>null;
        data["success"] = this.success !== undefined ? this.success : <any>null;
        if (this.errors && this.errors.constructor === Array) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        return data; 
    }
}

export interface IApiResultOfPagedResultDataOfIEnumerableOfNewsPostViewModel {
    data?: PagedResultDataOfIEnumerableOfNewsPostViewModel | null;
    success?: boolean | null;
    errors?: string[] | null;
}

export class PagedResultDataOfIEnumerableOfNewsPostViewModel implements IPagedResultDataOfIEnumerableOfNewsPostViewModel {
    content?: NewsPostViewModel[] | null;
    recordCount?: number | null;
    currentIndex?: number | null;
    currentCountPerPage?: number | null;
    pageCount?: number | null;

    constructor(data?: IPagedResultDataOfIEnumerableOfNewsPostViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["content"] && data["content"].constructor === Array) {
                this.content = [] as any;
                for (let item of data["content"])
                    this.content!.push(NewsPostViewModel.fromJS(item));
            }
            this.recordCount = data["recordCount"] !== undefined ? data["recordCount"] : <any>null;
            this.currentIndex = data["currentIndex"] !== undefined ? data["currentIndex"] : <any>null;
            this.currentCountPerPage = data["currentCountPerPage"] !== undefined ? data["currentCountPerPage"] : <any>null;
            this.pageCount = data["pageCount"] !== undefined ? data["pageCount"] : <any>null;
        }
    }

    static fromJS(data: any): PagedResultDataOfIEnumerableOfNewsPostViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDataOfIEnumerableOfNewsPostViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.content && this.content.constructor === Array) {
            data["content"] = [];
            for (let item of this.content)
                data["content"].push(item.toJSON());
        }
        data["recordCount"] = this.recordCount !== undefined ? this.recordCount : <any>null;
        data["currentIndex"] = this.currentIndex !== undefined ? this.currentIndex : <any>null;
        data["currentCountPerPage"] = this.currentCountPerPage !== undefined ? this.currentCountPerPage : <any>null;
        data["pageCount"] = this.pageCount !== undefined ? this.pageCount : <any>null;
        return data; 
    }
}

export interface IPagedResultDataOfIEnumerableOfNewsPostViewModel {
    content?: NewsPostViewModel[] | null;
    recordCount?: number | null;
    currentIndex?: number | null;
    currentCountPerPage?: number | null;
    pageCount?: number | null;
}

export class NewsPostViewModel implements INewsPostViewModel {
    id?: string | null;
    caption!: string;
    content?: string | null;
    imageUrlSmallTile?: string | null;
    imageUrlBigTile?: string | null;
    imageUrlBanner?: string | null;
    forumPostUrl?: string | null;
    tags?: string | null;
    public?: boolean | null;
    createdOn?: Date | null;

    constructor(data?: INewsPostViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"] !== undefined ? data["id"] : <any>null;
            this.caption = data["caption"] !== undefined ? data["caption"] : <any>null;
            this.content = data["content"] !== undefined ? data["content"] : <any>null;
            this.imageUrlSmallTile = data["imageUrlSmallTile"] !== undefined ? data["imageUrlSmallTile"] : <any>null;
            this.imageUrlBigTile = data["imageUrlBigTile"] !== undefined ? data["imageUrlBigTile"] : <any>null;
            this.imageUrlBanner = data["imageUrlBanner"] !== undefined ? data["imageUrlBanner"] : <any>null;
            this.forumPostUrl = data["forumPostUrl"] !== undefined ? data["forumPostUrl"] : <any>null;
            this.tags = data["tags"] !== undefined ? data["tags"] : <any>null;
            this.public = data["public"] !== undefined ? data["public"] : <any>null;
            this.createdOn = data["createdOn"] ? new Date(data["createdOn"].toString()) : <any>null;
        }
    }

    static fromJS(data: any): NewsPostViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new NewsPostViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["caption"] = this.caption !== undefined ? this.caption : <any>null;
        data["content"] = this.content !== undefined ? this.content : <any>null;
        data["imageUrlSmallTile"] = this.imageUrlSmallTile !== undefined ? this.imageUrlSmallTile : <any>null;
        data["imageUrlBigTile"] = this.imageUrlBigTile !== undefined ? this.imageUrlBigTile : <any>null;
        data["imageUrlBanner"] = this.imageUrlBanner !== undefined ? this.imageUrlBanner : <any>null;
        data["forumPostUrl"] = this.forumPostUrl !== undefined ? this.forumPostUrl : <any>null;
        data["tags"] = this.tags !== undefined ? this.tags : <any>null;
        data["public"] = this.public !== undefined ? this.public : <any>null;
        data["createdOn"] = this.createdOn ? this.createdOn.toISOString() : <any>null;
        return data; 
    }
}

export interface INewsPostViewModel {
    id?: string | null;
    caption: string;
    content?: string | null;
    imageUrlSmallTile?: string | null;
    imageUrlBigTile?: string | null;
    imageUrlBanner?: string | null;
    forumPostUrl?: string | null;
    tags?: string | null;
    public?: boolean | null;
    createdOn?: Date | null;
}

export class ApiResultOfNewsPostViewModel implements IApiResultOfNewsPostViewModel {
    data?: NewsPostViewModel | null;
    success?: boolean | null;
    errors?: string[] | null;

    constructor(data?: IApiResultOfNewsPostViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.data = data["data"] ? NewsPostViewModel.fromJS(data["data"]) : <any>null;
            this.success = data["success"] !== undefined ? data["success"] : <any>null;
            if (data["errors"] && data["errors"].constructor === Array) {
                this.errors = [] as any;
                for (let item of data["errors"])
                    this.errors!.push(item);
            }
        }
    }

    static fromJS(data: any): ApiResultOfNewsPostViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new ApiResultOfNewsPostViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data"] = this.data ? this.data.toJSON() : <any>null;
        data["success"] = this.success !== undefined ? this.success : <any>null;
        if (this.errors && this.errors.constructor === Array) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        return data; 
    }
}

export interface IApiResultOfNewsPostViewModel {
    data?: NewsPostViewModel | null;
    success?: boolean | null;
    errors?: string[] | null;
}

export class ApiResultOfStringOf implements IApiResultOfStringOf {
    data?: string[] | null;
    success?: boolean | null;
    errors?: string[] | null;

    constructor(data?: IApiResultOfStringOf) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["data"] && data["data"].constructor === Array) {
                this.data = [] as any;
                for (let item of data["data"])
                    this.data!.push(item);
            }
            this.success = data["success"] !== undefined ? data["success"] : <any>null;
            if (data["errors"] && data["errors"].constructor === Array) {
                this.errors = [] as any;
                for (let item of data["errors"])
                    this.errors!.push(item);
            }
        }
    }

    static fromJS(data: any): ApiResultOfStringOf {
        data = typeof data === 'object' ? data : {};
        let result = new ApiResultOfStringOf();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.data && this.data.constructor === Array) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item);
        }
        data["success"] = this.success !== undefined ? this.success : <any>null;
        if (this.errors && this.errors.constructor === Array) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        return data; 
    }
}

export interface IApiResultOfStringOf {
    data?: string[] | null;
    success?: boolean | null;
    errors?: string[] | null;
}

export class UpdateRolesViewModel implements IUpdateRolesViewModel {
    userId?: string | null;
    roles?: string[] | null;

    constructor(data?: IUpdateRolesViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.userId = data["userId"] !== undefined ? data["userId"] : <any>null;
            if (data["roles"] && data["roles"].constructor === Array) {
                this.roles = [] as any;
                for (let item of data["roles"])
                    this.roles!.push(item);
            }
        }
    }

    static fromJS(data: any): UpdateRolesViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateRolesViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId !== undefined ? this.userId : <any>null;
        if (this.roles && this.roles.constructor === Array) {
            data["roles"] = [];
            for (let item of this.roles)
                data["roles"].push(item);
        }
        return data; 
    }
}

export interface IUpdateRolesViewModel {
    userId?: string | null;
    roles?: string[] | null;
}

export class ApiResultOfUpdateRolesViewModel implements IApiResultOfUpdateRolesViewModel {
    data?: UpdateRolesViewModel | null;
    success?: boolean | null;
    errors?: string[] | null;

    constructor(data?: IApiResultOfUpdateRolesViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.data = data["data"] ? UpdateRolesViewModel.fromJS(data["data"]) : <any>null;
            this.success = data["success"] !== undefined ? data["success"] : <any>null;
            if (data["errors"] && data["errors"].constructor === Array) {
                this.errors = [] as any;
                for (let item of data["errors"])
                    this.errors!.push(item);
            }
        }
    }

    static fromJS(data: any): ApiResultOfUpdateRolesViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new ApiResultOfUpdateRolesViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data"] = this.data ? this.data.toJSON() : <any>null;
        data["success"] = this.success !== undefined ? this.success : <any>null;
        if (this.errors && this.errors.constructor === Array) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        return data; 
    }
}

export interface IApiResultOfUpdateRolesViewModel {
    data?: UpdateRolesViewModel | null;
    success?: boolean | null;
    errors?: string[] | null;
}

export class ApiResultOfIEnumerableOfServiceStatusViewModel implements IApiResultOfIEnumerableOfServiceStatusViewModel {
    data?: ServiceStatusViewModel[] | null;
    success?: boolean | null;
    errors?: string[] | null;

    constructor(data?: IApiResultOfIEnumerableOfServiceStatusViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["data"] && data["data"].constructor === Array) {
                this.data = [] as any;
                for (let item of data["data"])
                    this.data!.push(ServiceStatusViewModel.fromJS(item));
            }
            this.success = data["success"] !== undefined ? data["success"] : <any>null;
            if (data["errors"] && data["errors"].constructor === Array) {
                this.errors = [] as any;
                for (let item of data["errors"])
                    this.errors!.push(item);
            }
        }
    }

    static fromJS(data: any): ApiResultOfIEnumerableOfServiceStatusViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new ApiResultOfIEnumerableOfServiceStatusViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.data && this.data.constructor === Array) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["success"] = this.success !== undefined ? this.success : <any>null;
        if (this.errors && this.errors.constructor === Array) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        return data; 
    }
}

export interface IApiResultOfIEnumerableOfServiceStatusViewModel {
    data?: ServiceStatusViewModel[] | null;
    success?: boolean | null;
    errors?: string[] | null;
}

export class ServiceStatusViewModel implements IServiceStatusViewModel {
    id?: string | null;
    service!: string;
    timeStamp?: Date | null;
    state?: number | null;

    constructor(data?: IServiceStatusViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"] !== undefined ? data["id"] : <any>null;
            this.service = data["service"] !== undefined ? data["service"] : <any>null;
            this.timeStamp = data["timeStamp"] ? new Date(data["timeStamp"].toString()) : <any>null;
            this.state = data["state"] !== undefined ? data["state"] : <any>null;
        }
    }

    static fromJS(data: any): ServiceStatusViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new ServiceStatusViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["service"] = this.service !== undefined ? this.service : <any>null;
        data["timeStamp"] = this.timeStamp ? this.timeStamp.toISOString() : <any>null;
        data["state"] = this.state !== undefined ? this.state : <any>null;
        return data; 
    }
}

export interface IServiceStatusViewModel {
    id?: string | null;
    service: string;
    timeStamp?: Date | null;
    state?: number | null;
}

export class ApiResultOfServiceStatusViewModel implements IApiResultOfServiceStatusViewModel {
    data?: ServiceStatusViewModel | null;
    success?: boolean | null;
    errors?: string[] | null;

    constructor(data?: IApiResultOfServiceStatusViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.data = data["data"] ? ServiceStatusViewModel.fromJS(data["data"]) : <any>null;
            this.success = data["success"] !== undefined ? data["success"] : <any>null;
            if (data["errors"] && data["errors"].constructor === Array) {
                this.errors = [] as any;
                for (let item of data["errors"])
                    this.errors!.push(item);
            }
        }
    }

    static fromJS(data: any): ApiResultOfServiceStatusViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new ApiResultOfServiceStatusViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data"] = this.data ? this.data.toJSON() : <any>null;
        data["success"] = this.success !== undefined ? this.success : <any>null;
        if (this.errors && this.errors.constructor === Array) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        return data; 
    }
}

export interface IApiResultOfServiceStatusViewModel {
    data?: ServiceStatusViewModel | null;
    success?: boolean | null;
    errors?: string[] | null;
}

export class SwaggerException extends Error {
    message: string;
    status: number; 
    response: string; 
    headers: { [key: string]: any; };
    result: any; 

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isSwaggerException = true;

    static isSwaggerException(obj: any): obj is SwaggerException {
        return obj.isSwaggerException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    if(result !== null && result !== undefined)
        return _observableThrow(result);
    else
        return _observableThrow(new SwaggerException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            let reader = new FileReader(); 
            reader.onload = event => { 
                observer.next((<any>event.target).result);
                observer.complete();
            };
            reader.readAsText(blob); 
        }
    });
}